
/* Autogenerated. Do not edit. */

import Foundation
public class Sharing {
    /// Who can access a shared link. The most open visibility is `public`. The
    /// default depends on many aspects, such as team and user preferences and
    /// shared folder settings.
    ///
    /// - Public:
    ///   Anyone who has received the link can access it. No login required.
    /// - TeamOnly:
    ///   Only members of the same DfB (Dropbox for Business) team can access
    ///   the link. Login is required.
    /// - Password:
    ///   A link-specific password is required to access the link. Login is not
    ///   required.
    /// - TeamAndPassword:
    ///   Only members of the same DfB (Dropbox for Business) team who have the
    ///   link-specific password can access the link.
    /// - SharedFolderOnly:
    ///   Only members of the shared folder containing the linked file can
    ///   access the link. Login is required.
    /// - Other:
    ///   An unknown restriction is in place.
    public enum Visibility : CustomStringConvertible {
        case Public
        case TeamOnly
        case Password
        case TeamAndPassword
        case SharedFolderOnly
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(VisibilitySerializer().serialize(self)))"
        }
    }
    public class VisibilitySerializer: JSONSerializer {
        public init() { }
        public func serialize(value: Visibility) -> JSON {
            switch value {
                case .Public:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("public")
                    return .Dictionary(d)
                case .TeamOnly:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("team_only")
                    return .Dictionary(d)
                case .Password:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("password")
                    return .Dictionary(d)
                case .TeamAndPassword:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("team_and_password")
                    return .Dictionary(d)
                case .SharedFolderOnly:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("shared_folder_only")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> Visibility {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "public":
                            return Visibility.Public
                        case "team_only":
                            return Visibility.TeamOnly
                        case "password":
                            return Visibility.Password
                        case "team_and_password":
                            return Visibility.TeamAndPassword
                        case "shared_folder_only":
                            return Visibility.SharedFolderOnly
                        case "other":
                            return Visibility.Other
                        default:
                            return Visibility.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /// Metadata for a shared link. This can be either a `PathLinkMetadata` or
    /// `CollectionLinkMetadata`.
    ///
    /// :param: url
    ///        URL of the shared link.
    /// :param: visibility
    ///        Who can access the link.
    /// :param: expires
    ///        Expiration time, if set. By default the link won't expire.
    public class LinkMetadata: CustomStringConvertible {
        public let url : String
        public let visibility : Sharing.Visibility
        public let expires : NSDate?
        public init(url: String, visibility: Sharing.Visibility, expires: NSDate? = nil) {
            stringValidator()(value: url)
            self.url = url
            self.visibility = visibility
            self.expires = expires
        }
        public var description : String {
            return "\(prepareJSONForSerialization(LinkMetadataSerializer().serialize(self)))"
        }
    }
    public class LinkMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: LinkMetadata) -> JSON {
            var output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            "visibility": Sharing.VisibilitySerializer().serialize(value.visibility),
            "expires": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expires),
            ]
            switch value {
                case let path as Sharing.PathLinkMetadata:
                    for (k,v) in Serialization.getFields(Sharing.PathLinkMetadataSerializer().serialize(path)) {
                        output[k] = v
                    }
                    output[".tag"] = .Str("path")
                case let collection as Sharing.CollectionLinkMetadata:
                    for (k,v) in Serialization.getFields(Sharing.CollectionLinkMetadataSerializer().serialize(collection)) {
                        output[k] = v
                    }
                    output[".tag"] = .Str("collection")
                default: fatalError("Tried to serialize unexpected subtype")
            }
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> LinkMetadata {
            switch json {
                case .Dictionary(let dict):
                    let tag = Serialization.getTag(dict)
                    switch tag {
                        case "path":
                            return Sharing.PathLinkMetadataSerializer().deserialize(json)
                        case "collection":
                            return Sharing.CollectionLinkMetadataSerializer().deserialize(json)
                        default:
                            let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .Null)
                            let visibility = Sharing.VisibilitySerializer().deserialize(dict["visibility"] ?? .Null)
                            let expires = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expires"] ?? .Null)
                            return LinkMetadata(url: url, visibility: visibility, expires: expires)
                    }
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /// Metadata for a path-based shared link.
    ///
    /// :param: path
    ///        Path in user's Dropbox.
    public class PathLinkMetadata: LinkMetadata {
        public let path : String
        public init(url: String, visibility: Sharing.Visibility, path: String, expires: NSDate? = nil) {
            stringValidator()(value: path)
            self.path = path
            super.init(url: url, visibility: visibility, expires: expires)
        }
        public override var description : String {
            return "\(prepareJSONForSerialization(PathLinkMetadataSerializer().serialize(self)))"
        }
    }
    public class PathLinkMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: PathLinkMetadata) -> JSON {
            let output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            "visibility": Sharing.VisibilitySerializer().serialize(value.visibility),
            "path": Serialization._StringSerializer.serialize(value.path),
            "expires": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expires),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> PathLinkMetadata {
            switch json {
                case .Dictionary(let dict):
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .Null)
                    let visibility = Sharing.VisibilitySerializer().deserialize(dict["visibility"] ?? .Null)
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    let expires = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expires"] ?? .Null)
                    return PathLinkMetadata(url: url, visibility: visibility, path: path, expires: expires)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /// Metadata for a collection-based shared link.
    ///
    public class CollectionLinkMetadata: LinkMetadata {
        public override var description : String {
            return "\(prepareJSONForSerialization(CollectionLinkMetadataSerializer().serialize(self)))"
        }
    }
    public class CollectionLinkMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: CollectionLinkMetadata) -> JSON {
            let output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            "visibility": Sharing.VisibilitySerializer().serialize(value.visibility),
            "expires": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expires),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> CollectionLinkMetadata {
            switch json {
                case .Dictionary(let dict):
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .Null)
                    let visibility = Sharing.VisibilitySerializer().deserialize(dict["visibility"] ?? .Null)
                    let expires = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expires"] ?? .Null)
                    return CollectionLinkMetadata(url: url, visibility: visibility, expires: expires)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /// The GetSharedLinksArg struct
    ///
    /// :param: path
    ///        See `get_shared_links` description.
    public class GetSharedLinksArg: CustomStringConvertible {
        public let path : String?
        public init(path: String? = nil) {
            nullableValidator(stringValidator())(value: path)
            self.path = path
        }
        public var description : String {
            return "\(prepareJSONForSerialization(GetSharedLinksArgSerializer().serialize(self)))"
        }
    }
    public class GetSharedLinksArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GetSharedLinksArg) -> JSON {
            let output = [ 
            "path": NullableSerializer(Serialization._StringSerializer).serialize(value.path),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GetSharedLinksArg {
            switch json {
                case .Dictionary(let dict):
                    let path = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path"] ?? .Null)
                    return GetSharedLinksArg(path: path)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /// The GetSharedLinksResult struct
    ///
    /// :param: links
    ///        Shared links applicable to the path argument.
    public class GetSharedLinksResult: CustomStringConvertible {
        public let links : Array<Sharing.LinkMetadata>
        public init(links: Array<Sharing.LinkMetadata>) {
            self.links = links
        }
        public var description : String {
            return "\(prepareJSONForSerialization(GetSharedLinksResultSerializer().serialize(self)))"
        }
    }
    public class GetSharedLinksResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GetSharedLinksResult) -> JSON {
            let output = [ 
            "links": ArraySerializer(Sharing.LinkMetadataSerializer()).serialize(value.links),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GetSharedLinksResult {
            switch json {
                case .Dictionary(let dict):
                    let links = ArraySerializer(Sharing.LinkMetadataSerializer()).deserialize(dict["links"] ?? .Null)
                    return GetSharedLinksResult(links: links)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /// The GetSharedLinksError union
    ///
    /// - Path
    /// - Other
    public enum GetSharedLinksError : CustomStringConvertible {
        case Path(String?)
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(GetSharedLinksErrorSerializer().serialize(self)))"
        }
    }
    public class GetSharedLinksErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GetSharedLinksError) -> JSON {
            switch value {
                case .Path(let arg):
                    var d = ["path": NullableSerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .Str("path")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> GetSharedLinksError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Serialization._StringSerializer.deserialize(d["path"] ?? .Null)
                            return GetSharedLinksError.Path(v)
                        case "other":
                            return GetSharedLinksError.Other
                        default:
                            return GetSharedLinksError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /// Flag to indicate pending upload default (for linking to not-yet-existing
    /// paths).
    ///
    /// - File:
    ///   Assume pending uploads are files.
    /// - Folder:
    ///   Assume pending uploads are folders.
    public enum PendingUploadMode : CustomStringConvertible {
        case File
        case Folder
        public var description : String {
            return "\(prepareJSONForSerialization(PendingUploadModeSerializer().serialize(self)))"
        }
    }
    public class PendingUploadModeSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: PendingUploadMode) -> JSON {
            switch value {
                case .File:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("file")
                    return .Dictionary(d)
                case .Folder:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("folder")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> PendingUploadMode {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "file":
                            return PendingUploadMode.File
                        case "folder":
                            return PendingUploadMode.Folder
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /// The CreateSharedLinkArg struct
    ///
    /// :param: path
    ///        The path to share.
    /// :param: shortUrl
    ///        Whether to return a shortened URL.
    /// :param: pendingUpload
    ///        If it's okay to share a path that does not yet exist, set this to
    ///        either 'file' or 'folder' to indicate whether to assume it's a
    ///        file or folder.
    public class CreateSharedLinkArg: CustomStringConvertible {
        public let path : String
        public let shortUrl : Bool
        public let pendingUpload : Sharing.PendingUploadMode?
        public init(path: String, shortUrl: Bool = false, pendingUpload: Sharing.PendingUploadMode? = nil) {
            stringValidator()(value: path)
            self.path = path
            self.shortUrl = shortUrl
            self.pendingUpload = pendingUpload
        }
        public var description : String {
            return "\(prepareJSONForSerialization(CreateSharedLinkArgSerializer().serialize(self)))"
        }
    }
    public class CreateSharedLinkArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: CreateSharedLinkArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "short_url": Serialization._BoolSerializer.serialize(value.shortUrl),
            "pending_upload": NullableSerializer(Sharing.PendingUploadModeSerializer()).serialize(value.pendingUpload),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> CreateSharedLinkArg {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    let shortUrl = Serialization._BoolSerializer.deserialize(dict["short_url"] ?? .Null)
                    let pendingUpload = NullableSerializer(Sharing.PendingUploadModeSerializer()).deserialize(dict["pending_upload"] ?? .Null)
                    return CreateSharedLinkArg(path: path, shortUrl: shortUrl, pendingUpload: pendingUpload)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /// The CreateSharedLinkError union
    ///
    /// - Path
    /// - Other
    public enum CreateSharedLinkError : CustomStringConvertible {
        case Path(Files.LookupError)
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(CreateSharedLinkErrorSerializer().serialize(self)))"
        }
    }
    public class CreateSharedLinkErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: CreateSharedLinkError) -> JSON {
            switch value {
                case .Path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("path")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> CreateSharedLinkError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .Null)
                            return CreateSharedLinkError.Path(v)
                        case "other":
                            return CreateSharedLinkError.Other
                        default:
                            return CreateSharedLinkError.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /// The access type fo this shared folder. Each type is associated with
    /// specific access permission.
    ///
    /// - Owner:
    ///   The member is the owner of the shared folder. The user can both view
    ///   and edit the shared folder.
    /// - Editor:
    ///   The member can both view and edit the shared folder.
    /// - Viewer:
    ///   The member can only view the shared folder.
    /// - Other:
    ///   An unknown access type.
    public enum AccessType : CustomStringConvertible {
        case Owner
        case Editor
        case Viewer
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(AccessTypeSerializer().serialize(self)))"
        }
    }
    public class AccessTypeSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: AccessType) -> JSON {
            switch value {
                case .Owner:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("owner")
                    return .Dictionary(d)
                case .Editor:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("editor")
                    return .Dictionary(d)
                case .Viewer:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("viewer")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> AccessType {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "owner":
                            return AccessType.Owner
                        case "editor":
                            return AccessType.Editor
                        case "viewer":
                            return AccessType.Viewer
                        case "other":
                            return AccessType.Other
                        default:
                            return AccessType.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /// Policy governing who can links be shared with.
    ///
    /// - All:
    ///   Links can be shared with anyone.
    /// - MembersOnly:
    ///   Links can only be shared among members of the shared folder.
    /// - Other:
    ///   An unknown shared link policy.
    public enum SharedLinkPolicy : CustomStringConvertible {
        case All
        case MembersOnly
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(SharedLinkPolicySerializer().serialize(self)))"
        }
    }
    public class SharedLinkPolicySerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SharedLinkPolicy) -> JSON {
            switch value {
                case .All:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("all")
                    return .Dictionary(d)
                case .MembersOnly:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("members_only")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> SharedLinkPolicy {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "all":
                            return SharedLinkPolicy.All
                        case "members_only":
                            return SharedLinkPolicy.MembersOnly
                        case "other":
                            return SharedLinkPolicy.Other
                        default:
                            return SharedLinkPolicy.Other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /// The information about a member of the shared folder.
    ///
    /// :param: accessType
    ///        This access type for this user member.
    public class MembershipInfo: CustomStringConvertible {
        public let accessType : Sharing.AccessType
        public init(accessType: Sharing.AccessType) {
            self.accessType = accessType
        }
        public var description : String {
            return "\(prepareJSONForSerialization(MembershipInfoSerializer().serialize(self)))"
        }
    }
    public class MembershipInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: MembershipInfo) -> JSON {
            let output = [ 
            "access_type": Sharing.AccessTypeSerializer().serialize(value.accessType),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> MembershipInfo {
            switch json {
                case .Dictionary(let dict):
                    let accessType = Sharing.AccessTypeSerializer().deserialize(dict["access_type"] ?? .Null)
                    return MembershipInfo(accessType: accessType)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /// The information about a user.
    ///
    /// :param: accountId
    ///        The account ID of the user.
    /// :param: displayName
    ///        The display name of the user.
    /// :param: sameTeam
    ///        If the user is in the same team as current user.
    /// :param: memberId
    ///        The member id of the user for the shared folder. This field will
    ///        only present if same_team field is true.
    public class UserInfo: CustomStringConvertible {
        public let accountId : String
        public let displayName : String
        public let sameTeam : Bool
        public let memberId : String?
        public init(accountId: String, displayName: String, sameTeam: Bool, memberId: String? = nil) {
            stringValidator(minLength: 40, maxLength: 40)(value: accountId)
            self.accountId = accountId
            stringValidator()(value: displayName)
            self.displayName = displayName
            self.sameTeam = sameTeam
            nullableValidator(stringValidator())(value: memberId)
            self.memberId = memberId
        }
        public var description : String {
            return "\(prepareJSONForSerialization(UserInfoSerializer().serialize(self)))"
        }
    }
    public class UserInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UserInfo) -> JSON {
            let output = [ 
            "account_id": Serialization._StringSerializer.serialize(value.accountId),
            "display_name": Serialization._StringSerializer.serialize(value.displayName),
            "same_team": Serialization._BoolSerializer.serialize(value.sameTeam),
            "member_id": NullableSerializer(Serialization._StringSerializer).serialize(value.memberId),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> UserInfo {
            switch json {
                case .Dictionary(let dict):
                    let accountId = Serialization._StringSerializer.deserialize(dict["account_id"] ?? .Null)
                    let displayName = Serialization._StringSerializer.deserialize(dict["display_name"] ?? .Null)
                    let sameTeam = Serialization._BoolSerializer.deserialize(dict["same_team"] ?? .Null)
                    let memberId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["member_id"] ?? .Null)
                    return UserInfo(accountId: accountId, displayName: displayName, sameTeam: sameTeam, memberId: memberId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /// The information about a user member of the shared folder.
    ///
    /// :param: user
    ///        The account information for the membership user.
    /// :param: active
    ///        If this membership is active. When the field is false, it means
    ///        the user has left the shared folder (but may still rejoin).
    public class UserMembershipInfo: MembershipInfo {
        public let user : Sharing.UserInfo
        public let active : Bool
        public init(accessType: Sharing.AccessType, user: Sharing.UserInfo, active: Bool) {
            self.user = user
            self.active = active
            super.init(accessType: accessType)
        }
        public override var description : String {
            return "\(prepareJSONForSerialization(UserMembershipInfoSerializer().serialize(self)))"
        }
    }
    public class UserMembershipInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UserMembershipInfo) -> JSON {
            let output = [ 
            "access_type": Sharing.AccessTypeSerializer().serialize(value.accessType),
            "user": Sharing.UserInfoSerializer().serialize(value.user),
            "active": Serialization._BoolSerializer.serialize(value.active),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> UserMembershipInfo {
            switch json {
                case .Dictionary(let dict):
                    let accessType = Sharing.AccessTypeSerializer().deserialize(dict["access_type"] ?? .Null)
                    let user = Sharing.UserInfoSerializer().deserialize(dict["user"] ?? .Null)
                    let active = Serialization._BoolSerializer.deserialize(dict["active"] ?? .Null)
                    return UserMembershipInfo(accessType: accessType, user: user, active: active)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /// The information about a group. Group is a way to manage a list of users
    /// who need same access permission to the shared folder.
    ///
    /// :param: displayName
    ///        The display name of the group.
    /// :param: id
    ///        The ID of the group.
    /// :param: memberCount
    ///        The total number of member for this group.
    /// :param: sameTeam
    ///        If all members of the group are in the same team as current user.
    public class GroupInfo: CustomStringConvertible {
        public let displayName : String
        public let id : String
        public let memberCount : Int64
        public let sameTeam : Bool
        public init(displayName: String, id: String, memberCount: Int64, sameTeam: Bool) {
            stringValidator()(value: displayName)
            self.displayName = displayName
            stringValidator()(value: id)
            self.id = id
            comparableValidator()(value: memberCount)
            self.memberCount = memberCount
            self.sameTeam = sameTeam
        }
        public var description : String {
            return "\(prepareJSONForSerialization(GroupInfoSerializer().serialize(self)))"
        }
    }
    public class GroupInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupInfo) -> JSON {
            let output = [ 
            "display_name": Serialization._StringSerializer.serialize(value.displayName),
            "id": Serialization._StringSerializer.serialize(value.id),
            "member_count": Serialization._Int64Serializer.serialize(value.memberCount),
            "same_team": Serialization._BoolSerializer.serialize(value.sameTeam),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GroupInfo {
            switch json {
                case .Dictionary(let dict):
                    let displayName = Serialization._StringSerializer.deserialize(dict["display_name"] ?? .Null)
                    let id = Serialization._StringSerializer.deserialize(dict["id"] ?? .Null)
                    let memberCount = Serialization._Int64Serializer.deserialize(dict["member_count"] ?? .Null)
                    let sameTeam = Serialization._BoolSerializer.deserialize(dict["same_team"] ?? .Null)
                    return GroupInfo(displayName: displayName, id: id, memberCount: memberCount, sameTeam: sameTeam)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /// The information about a group member of the shared folder.
    ///
    /// :param: group
    ///        The information about the membership group.
    public class GroupMembershipInfo: MembershipInfo {
        public let group : Sharing.GroupInfo
        public init(accessType: Sharing.AccessType, group: Sharing.GroupInfo) {
            self.group = group
            super.init(accessType: accessType)
        }
        public override var description : String {
            return "\(prepareJSONForSerialization(GroupMembershipInfoSerializer().serialize(self)))"
        }
    }
    public class GroupMembershipInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GroupMembershipInfo) -> JSON {
            let output = [ 
            "access_type": Sharing.AccessTypeSerializer().serialize(value.accessType),
            "group": Sharing.GroupInfoSerializer().serialize(value.group),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GroupMembershipInfo {
            switch json {
                case .Dictionary(let dict):
                    let accessType = Sharing.AccessTypeSerializer().deserialize(dict["access_type"] ?? .Null)
                    let group = Sharing.GroupInfoSerializer().deserialize(dict["group"] ?? .Null)
                    return GroupMembershipInfo(accessType: accessType, group: group)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /// The base type for shared folder metadata.
    ///
    /// :param: pathLower
    ///        The lower-cased full path of this shared folder. Absent for
    ///        unmounted folders.
    /// :param: name
    ///        The name of the this shared folder.
    /// :param: id
    ///        The ID of the shared folder.
    /// :param: accessType
    ///        Who can access this shared folder.
    /// :param: sharedLinkPolicy
    ///        Who links can be shared with.
    public class SharedFolderMetadata: CustomStringConvertible {
        public let pathLower : String?
        public let name : String
        public let id : String
        public let accessType : Sharing.AccessType
        public let sharedLinkPolicy : Sharing.SharedLinkPolicy
        public init(name: String, id: String, accessType: Sharing.AccessType, sharedLinkPolicy: Sharing.SharedLinkPolicy, pathLower: String? = nil) {
            nullableValidator(stringValidator())(value: pathLower)
            self.pathLower = pathLower
            stringValidator()(value: name)
            self.name = name
            stringValidator(pattern: "[-_0-9a-zA-Z]+")(value: id)
            self.id = id
            self.accessType = accessType
            self.sharedLinkPolicy = sharedLinkPolicy
        }
        public var description : String {
            return "\(prepareJSONForSerialization(SharedFolderMetadataSerializer().serialize(self)))"
        }
    }
    public class SharedFolderMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SharedFolderMetadata) -> JSON {
            var output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "id": Serialization._StringSerializer.serialize(value.id),
            "access_type": Sharing.AccessTypeSerializer().serialize(value.accessType),
            "shared_link_policy": Sharing.SharedLinkPolicySerializer().serialize(value.sharedLinkPolicy),
            "path_lower": NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
            ]
            switch value {
                case let basic as Sharing.BasicSharedFolderMetadata:
                    for (k,v) in Serialization.getFields(Sharing.BasicSharedFolderMetadataSerializer().serialize(basic)) {
                        output[k] = v
                    }
                    output[".tag"] = .Str("basic")
                case let full as Sharing.FullSharedFolderMetadata:
                    for (k,v) in Serialization.getFields(Sharing.FullSharedFolderMetadataSerializer().serialize(full)) {
                        output[k] = v
                    }
                    output[".tag"] = .Str("full")
                default: fatalError("Tried to serialize unexpected subtype")
            }
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> SharedFolderMetadata {
            switch json {
                case .Dictionary(let dict):
                    let tag = Serialization.getTag(dict)
                    switch tag {
                        case "basic":
                            return Sharing.BasicSharedFolderMetadataSerializer().deserialize(json)
                        case "full":
                            return Sharing.FullSharedFolderMetadataSerializer().deserialize(json)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /// The metadata which includes basic information about the shared folder.
    ///
    public class BasicSharedFolderMetadata: SharedFolderMetadata {
        public override var description : String {
            return "\(prepareJSONForSerialization(BasicSharedFolderMetadataSerializer().serialize(self)))"
        }
    }
    public class BasicSharedFolderMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: BasicSharedFolderMetadata) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "id": Serialization._StringSerializer.serialize(value.id),
            "access_type": Sharing.AccessTypeSerializer().serialize(value.accessType),
            "shared_link_policy": Sharing.SharedLinkPolicySerializer().serialize(value.sharedLinkPolicy),
            "path_lower": NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> BasicSharedFolderMetadata {
            switch json {
                case .Dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .Null)
                    let id = Serialization._StringSerializer.deserialize(dict["id"] ?? .Null)
                    let accessType = Sharing.AccessTypeSerializer().deserialize(dict["access_type"] ?? .Null)
                    let sharedLinkPolicy = Sharing.SharedLinkPolicySerializer().deserialize(dict["shared_link_policy"] ?? .Null)
                    let pathLower = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_lower"] ?? .Null)
                    return BasicSharedFolderMetadata(name: name, id: id, accessType: accessType, sharedLinkPolicy: sharedLinkPolicy, pathLower: pathLower)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /// The full metadata for the shared folder which includes user and group
    /// membership.
    ///
    /// :param: membership
    ///        The list of user members of the shared folder.
    /// :param: groups
    ///        The list of group members of the shared folder.
    public class FullSharedFolderMetadata: SharedFolderMetadata {
        public let membership : Array<Sharing.UserMembershipInfo>
        public let groups : Array<Sharing.GroupMembershipInfo>
        public init(name: String, id: String, accessType: Sharing.AccessType, sharedLinkPolicy: Sharing.SharedLinkPolicy, membership: Array<Sharing.UserMembershipInfo>, groups: Array<Sharing.GroupMembershipInfo>, pathLower: String? = nil) {
            self.membership = membership
            self.groups = groups
            super.init(name: name, id: id, accessType: accessType, sharedLinkPolicy: sharedLinkPolicy, pathLower: pathLower)
        }
        public override var description : String {
            return "\(prepareJSONForSerialization(FullSharedFolderMetadataSerializer().serialize(self)))"
        }
    }
    public class FullSharedFolderMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: FullSharedFolderMetadata) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "id": Serialization._StringSerializer.serialize(value.id),
            "access_type": Sharing.AccessTypeSerializer().serialize(value.accessType),
            "shared_link_policy": Sharing.SharedLinkPolicySerializer().serialize(value.sharedLinkPolicy),
            "membership": ArraySerializer(Sharing.UserMembershipInfoSerializer()).serialize(value.membership),
            "groups": ArraySerializer(Sharing.GroupMembershipInfoSerializer()).serialize(value.groups),
            "path_lower": NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> FullSharedFolderMetadata {
            switch json {
                case .Dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .Null)
                    let id = Serialization._StringSerializer.deserialize(dict["id"] ?? .Null)
                    let accessType = Sharing.AccessTypeSerializer().deserialize(dict["access_type"] ?? .Null)
                    let sharedLinkPolicy = Sharing.SharedLinkPolicySerializer().deserialize(dict["shared_link_policy"] ?? .Null)
                    let membership = ArraySerializer(Sharing.UserMembershipInfoSerializer()).deserialize(dict["membership"] ?? .Null)
                    let groups = ArraySerializer(Sharing.GroupMembershipInfoSerializer()).deserialize(dict["groups"] ?? .Null)
                    let pathLower = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_lower"] ?? .Null)
                    return FullSharedFolderMetadata(name: name, id: id, accessType: accessType, sharedLinkPolicy: sharedLinkPolicy, membership: membership, groups: groups, pathLower: pathLower)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /// There is an error accessing the shared folder.
    ///
    /// - InvalidId:
    ///   This shared folder ID is invalid.
    /// - NotMember:
    ///   The user is not a member of the shared folder thus cannot access it.
    /// - HasLeft:
    ///   The user has left the shared folder already thus is no longer able to
    ///   access it.
    /// - RequireOwner:
    ///   The user needs to be the owner to access the shared folder.
    /// - IsRoot:
    ///   The folder is a root folder and cannot be shared.
    /// - IsTeamSharedFolder:
    ///   The folder is a team shared folder and the user cannot access it.
    /// - IsAppFolder:
    ///   The folder is an app folder and cannot be shared.
    public enum SharedFolderAccessError : CustomStringConvertible {
        case InvalidId
        case NotMember
        case HasLeft
        case RequireOwner
        case IsRoot
        case IsTeamSharedFolder
        case IsAppFolder
        public var description : String {
            return "\(prepareJSONForSerialization(SharedFolderAccessErrorSerializer().serialize(self)))"
        }
    }
    public class SharedFolderAccessErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SharedFolderAccessError) -> JSON {
            switch value {
                case .InvalidId:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("invalid_id")
                    return .Dictionary(d)
                case .NotMember:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("not_member")
                    return .Dictionary(d)
                case .HasLeft:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("has_left")
                    return .Dictionary(d)
                case .RequireOwner:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("require_owner")
                    return .Dictionary(d)
                case .IsRoot:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("is_root")
                    return .Dictionary(d)
                case .IsTeamSharedFolder:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("is_team_shared_folder")
                    return .Dictionary(d)
                case .IsAppFolder:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("is_app_folder")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> SharedFolderAccessError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_id":
                            return SharedFolderAccessError.InvalidId
                        case "not_member":
                            return SharedFolderAccessError.NotMember
                        case "has_left":
                            return SharedFolderAccessError.HasLeft
                        case "require_owner":
                            return SharedFolderAccessError.RequireOwner
                        case "is_root":
                            return SharedFolderAccessError.IsRoot
                        case "is_team_shared_folder":
                            return SharedFolderAccessError.IsTeamSharedFolder
                        case "is_app_folder":
                            return SharedFolderAccessError.IsAppFolder
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /// The GetSharedFolderArgs struct
    ///
    /// :param: id
    ///        The ID for the shared folder.
    /// :param: includeMembership
    ///        If include user and group membership information in the response.
    public class GetSharedFolderArgs: CustomStringConvertible {
        public let id : String
        public let includeMembership : Bool
        public init(id: String, includeMembership: Bool = true) {
            stringValidator(pattern: "[-_0-9a-zA-Z]+")(value: id)
            self.id = id
            self.includeMembership = includeMembership
        }
        public var description : String {
            return "\(prepareJSONForSerialization(GetSharedFolderArgsSerializer().serialize(self)))"
        }
    }
    public class GetSharedFolderArgsSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GetSharedFolderArgs) -> JSON {
            let output = [ 
            "id": Serialization._StringSerializer.serialize(value.id),
            "include_membership": Serialization._BoolSerializer.serialize(value.includeMembership),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GetSharedFolderArgs {
            switch json {
                case .Dictionary(let dict):
                    let id = Serialization._StringSerializer.deserialize(dict["id"] ?? .Null)
                    let includeMembership = Serialization._BoolSerializer.deserialize(dict["include_membership"] ?? .Null)
                    return GetSharedFolderArgs(id: id, includeMembership: includeMembership)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /// The ListSharedFoldersArgs struct
    ///
    /// :param: includeMembership
    ///        If include user and group membership information in the response.
    /// :param: showUnmounted
    ///        Determines whether the returned list of shared folders will
    ///        include folders  that the user has left (but may still rejoin).
    public class ListSharedFoldersArgs: CustomStringConvertible {
        public let includeMembership : Bool
        public let showUnmounted : Bool
        public init(includeMembership: Bool = false, showUnmounted: Bool = false) {
            self.includeMembership = includeMembership
            self.showUnmounted = showUnmounted
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ListSharedFoldersArgsSerializer().serialize(self)))"
        }
    }
    public class ListSharedFoldersArgsSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListSharedFoldersArgs) -> JSON {
            let output = [ 
            "include_membership": Serialization._BoolSerializer.serialize(value.includeMembership),
            "show_unmounted": Serialization._BoolSerializer.serialize(value.showUnmounted),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListSharedFoldersArgs {
            switch json {
                case .Dictionary(let dict):
                    let includeMembership = Serialization._BoolSerializer.deserialize(dict["include_membership"] ?? .Null)
                    let showUnmounted = Serialization._BoolSerializer.deserialize(dict["show_unmounted"] ?? .Null)
                    return ListSharedFoldersArgs(includeMembership: includeMembership, showUnmounted: showUnmounted)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /// Result for `list_shared_folders`. Unmounted shared folders can be
    /// identified by the absence of `SharedFolderMetadata.path_lower`.
    ///
    /// :param: entries
    ///        List of all shared folders the authenticated user has access to.
    public class ListSharedFoldersResult: CustomStringConvertible {
        public let entries : Array<Sharing.SharedFolderMetadata>
        public init(entries: Array<Sharing.SharedFolderMetadata>) {
            self.entries = entries
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ListSharedFoldersResultSerializer().serialize(self)))"
        }
    }
    public class ListSharedFoldersResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListSharedFoldersResult) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Sharing.SharedFolderMetadataSerializer()).serialize(value.entries),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListSharedFoldersResult {
            switch json {
                case .Dictionary(let dict):
                    let entries = ArraySerializer(Sharing.SharedFolderMetadataSerializer()).deserialize(dict["entries"] ?? .Null)
                    return ListSharedFoldersResult(entries: entries)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
}
extension BabelClient {
    /// Returns a list of :type:`LinkMetadata` objects for this user, including
    /// collection links. If no path is given or the path is empty, returns a
    /// list of all shared links for the current user, including collection
    /// links. If a non-empty path is given, returns a list of all shared links
    /// that allow access to the given path.  Collection links are never
    /// returned in this case. Note that the url field in the response is never
    /// the shortened URL. This API is not supported for App Folder and
    /// filetypes apps.
    ///
    /// :param: path
    ///        See `get_shared_links` description.
    public func sharingGetSharedLinks(path: String? = nil) -> BabelRpcRequest<Sharing.GetSharedLinksResultSerializer, Sharing.GetSharedLinksErrorSerializer> {
        let request = Sharing.GetSharedLinksArg(path: path)
        return BabelRpcRequest(client: self, host: "meta", route: "/sharing/get_shared_links", params: Sharing.GetSharedLinksArgSerializer().serialize(request), responseSerializer: Sharing.GetSharedLinksResultSerializer(), errorSerializer: Sharing.GetSharedLinksErrorSerializer())
    }
    /// Create a shared link. If a shared link already exists for the given
    /// path, that link is returned. Note that in the returned
    /// :type:`PathLinkMetadata`, the url field is the shortened URL if the
    /// short_url argument is set to :val:`true`. This API is not supported for
    /// App Folder and filetypes apps.
    ///
    /// :param: path
    ///        The path to share.
    /// :param: shortUrl
    ///        Whether to return a shortened URL.
    /// :param: pendingUpload
    ///        If it's okay to share a path that does not yet exist, set this to
    ///        either 'file' or 'folder' to indicate whether to assume it's a
    ///        file or folder.
    public func sharingCreateSharedLink(path path: String, shortUrl: Bool = false, pendingUpload: Sharing.PendingUploadMode? = nil) -> BabelRpcRequest<Sharing.PathLinkMetadataSerializer, Sharing.CreateSharedLinkErrorSerializer> {
        let request = Sharing.CreateSharedLinkArg(path: path, shortUrl: shortUrl, pendingUpload: pendingUpload)
        return BabelRpcRequest(client: self, host: "meta", route: "/sharing/create_shared_link", params: Sharing.CreateSharedLinkArgSerializer().serialize(request), responseSerializer: Sharing.PathLinkMetadataSerializer(), errorSerializer: Sharing.CreateSharedLinkErrorSerializer())
    }
    /// Gets shared folder by its folder ID.
    ///
    /// :param: id
    ///        The ID for the shared folder.
    /// :param: includeMembership
    ///        If include user and group membership information in the response.
    public func sharingGetSharedFolder(id id: String, includeMembership: Bool = true) -> BabelRpcRequest<Sharing.SharedFolderMetadataSerializer, Sharing.SharedFolderAccessErrorSerializer> {
        let request = Sharing.GetSharedFolderArgs(id: id, includeMembership: includeMembership)
        return BabelRpcRequest(client: self, host: "meta", route: "/sharing/get_shared_folder", params: Sharing.GetSharedFolderArgsSerializer().serialize(request), responseSerializer: Sharing.SharedFolderMetadataSerializer(), errorSerializer: Sharing.SharedFolderAccessErrorSerializer())
    }
    /// Return the list of all shared folders the authenticated user has access
    /// to.
    ///
    /// :param: includeMembership
    ///        If include user and group membership information in the response.
    /// :param: showUnmounted
    ///        Determines whether the returned list of shared folders will
    ///        include folders  that the user has left (but may still rejoin).
    public func sharingListSharedFolders(includeMembership: Bool = false, showUnmounted: Bool = false) -> BabelRpcRequest<Sharing.ListSharedFoldersResultSerializer, VoidSerializer> {
        let request = Sharing.ListSharedFoldersArgs(includeMembership: includeMembership, showUnmounted: showUnmounted)
        return BabelRpcRequest(client: self, host: "meta", route: "/sharing/list_shared_folders", params: Sharing.ListSharedFoldersArgsSerializer().serialize(request), responseSerializer: Sharing.ListSharedFoldersResultSerializer(), errorSerializer: Serialization._VoidSerializer)
    }
}
