
/* Autogenerated. Do not edit. */

import Foundation
public class Files {
    /// Metadata for a file or folder.
    ///
    /// :param: name
    ///        The last component of the path (including extension). This never
    ///        contains a slash.
    /// :param: pathLower
    ///        The lowercased full path in the user's Dropbox. This always
    ///        starts with a slash.
    public class Metadata: CustomStringConvertible {
        public let name : String
        public let pathLower : String
        public init(name: String, pathLower: String) {
            stringValidator()(value: name)
            self.name = name
            stringValidator()(value: pathLower)
            self.pathLower = pathLower
        }
        public var description : String {
            return "\(prepareJSONForSerialization(MetadataSerializer().serialize(self)))"
        }
    }
    public class MetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: Metadata) -> JSON {
            var output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "path_lower": Serialization._StringSerializer.serialize(value.pathLower),
            ]
            switch value {
                case let file as Files.FileMetadata:
                    for (k,v) in Serialization.getFields(FileMetadataSerializer().serialize(file)) {
                        output[k] = v
                    }
                    output[".tag"] = .Str("file")
                case let folder as Files.FolderMetadata:
                    for (k,v) in Serialization.getFields(FolderMetadataSerializer().serialize(folder)) {
                        output[k] = v
                    }
                    output[".tag"] = .Str("folder")
                case let deleted as Files.DeletedMetadata:
                    for (k,v) in Serialization.getFields(DeletedMetadataSerializer().serialize(deleted)) {
                        output[k] = v
                    }
                    output[".tag"] = .Str("deleted")
                default: fatalError("Tried to serialize unexpected subtype")
            }
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> Metadata {
            switch json {
                case .Dictionary(let dict):
                    let tag = Serialization.getTag(dict)
                    switch tag {
                        case "file":
                            return FileMetadataSerializer().deserialize(json)
                        case "folder":
                            return FolderMetadataSerializer().deserialize(json)
                        case "deleted":
                            return DeletedMetadataSerializer().deserialize(json)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Metadata (excluding name or path) for a file.
    ///
    /// :param: id
    ///        A unique identifier for the file.
    /// :param: clientModified
    ///        For files, this is the modification time set by the desktop
    ///        client when the file was added to Dropbox. Since this time is not
    ///        verified (the Dropbox server stores whatever the desktop client
    ///        sends up), this should only be used for display purposes (such as
    ///        sorting) and not, for example, to determine if a file has changed
    ///        or not.
    /// :param: serverModified
    ///        The last time the file was modified on Dropbox.
    /// :param: rev
    ///        A unique identifier for the current revision of a file. This
    ///        field is the same rev as elsewhere in the API and can be used to
    ///        detect changes and avoid conflicts.
    /// :param: size
    ///        The file size in bytes.
    public class FileMetadata: Metadata {
        public let id : String?
        public let clientModified : NSDate
        public let serverModified : NSDate
        public let rev : String
        public let size : UInt64
        public init(name: String, pathLower: String, clientModified: NSDate, serverModified: NSDate, rev: String, size: UInt64, id: String? = nil) {
            nullableValidator(stringValidator(minLength: 1))(value: id)
            self.id = id
            self.clientModified = clientModified
            self.serverModified = serverModified
            stringValidator(minLength: 9, pattern: "[0-9a-f]+")(value: rev)
            self.rev = rev
            comparableValidator()(value: size)
            self.size = size
            super.init(name: name, pathLower: pathLower)
        }
        public override var description : String {
            return "\(prepareJSONForSerialization(FileMetadataSerializer().serialize(self)))"
        }
    }
    public class FileMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: FileMetadata) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "path_lower": Serialization._StringSerializer.serialize(value.pathLower),
            "client_modified": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.clientModified),
            "server_modified": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.serverModified),
            "rev": Serialization._StringSerializer.serialize(value.rev),
            "size": Serialization._UInt64Serializer.serialize(value.size),
            "id": NullableSerializer(Serialization._StringSerializer).serialize(value.id),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> FileMetadata {
            switch json {
                case .Dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .Null)
                    let pathLower = Serialization._StringSerializer.deserialize(dict["path_lower"] ?? .Null)
                    let clientModified = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["client_modified"] ?? .Null)
                    let serverModified = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["server_modified"] ?? .Null)
                    let rev = Serialization._StringSerializer.deserialize(dict["rev"] ?? .Null)
                    let size = Serialization._UInt64Serializer.deserialize(dict["size"] ?? .Null)
                    let id = NullableSerializer(Serialization._StringSerializer).deserialize(dict["id"] ?? .Null)
                    return FileMetadata(name: name, pathLower: pathLower, clientModified: clientModified, serverModified: serverModified, rev: rev, size: size, id: id)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Metadata (excluding name or path) for a folder. (There are currently no
    /// fields defined here, but we will add folder-specific metadata in the
    /// future.)
    ///
    /// :param: id
    ///        A unique identifier for the folder.
    public class FolderMetadata: Metadata {
        public let id : String?
        public init(name: String, pathLower: String, id: String? = nil) {
            nullableValidator(stringValidator(minLength: 1))(value: id)
            self.id = id
            super.init(name: name, pathLower: pathLower)
        }
        public override var description : String {
            return "\(prepareJSONForSerialization(FolderMetadataSerializer().serialize(self)))"
        }
    }
    public class FolderMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: FolderMetadata) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "path_lower": Serialization._StringSerializer.serialize(value.pathLower),
            "id": NullableSerializer(Serialization._StringSerializer).serialize(value.id),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> FolderMetadata {
            switch json {
                case .Dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .Null)
                    let pathLower = Serialization._StringSerializer.deserialize(dict["path_lower"] ?? .Null)
                    let id = NullableSerializer(Serialization._StringSerializer).deserialize(dict["id"] ?? .Null)
                    return FolderMetadata(name: name, pathLower: pathLower, id: id)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Indicates a deleted file or folder in results returned by
    /// `list_folder/continue` or `search`.
    ///
    public class DeletedMetadata: Metadata {
        public override var description : String {
            return "\(prepareJSONForSerialization(DeletedMetadataSerializer().serialize(self)))"
        }
    }
    public class DeletedMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: DeletedMetadata) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "path_lower": Serialization._StringSerializer.serialize(value.pathLower),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> DeletedMetadata {
            switch json {
                case .Dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .Null)
                    let pathLower = Serialization._StringSerializer.deserialize(dict["path_lower"] ?? .Null)
                    return DeletedMetadata(name: name, pathLower: pathLower)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Error returned by `get_metadata`.
    ///
    /// - Path
    public enum GetMetadataError : CustomStringConvertible {
        case Path(Files.LookupError)
        public var description : String {
            return "\(prepareJSONForSerialization(GetMetadataErrorSerializer().serialize(self)))"
        }
    }
    public class GetMetadataErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GetMetadataError) -> JSON {
            switch value {
                case .Path(let arg):
                    var d = ["path": LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("path")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> GetMetadataError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = LookupErrorSerializer().deserialize(d["path"] ?? .Null)
                            return GetMetadataError.Path(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Arguments for `get_metadata`.
    ///
    /// :param: path
    ///        The path of a file or folder on Dropbox
    public class GetMetadataArg: CustomStringConvertible {
        public let path : String
        public init(path: String) {
            stringValidator(pattern: "((/|id:).*)|(rev:[0-9a-f]{9,})")(value: path)
            self.path = path
        }
        public var description : String {
            return "\(prepareJSONForSerialization(GetMetadataArgSerializer().serialize(self)))"
        }
    }
    public class GetMetadataArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: GetMetadataArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> GetMetadataArg {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    return GetMetadataArg(path: path)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Arguments for `list_folder/longpoll`.
    ///
    /// :param: cursor
    ///        A cursor as returned by `list_folder` or `list_folder/continue`
    /// :param: timeout
    ///        A timeout in seconds. The request will block for at most this
    ///        length of time, plus up to 90 seconds of random jitter added to
    ///        avoid the thundering herd problem. Care should be taken when
    ///        using this parameter, as some network infrastructure does not
    ///        support long timeouts.
    public class ListFolderLongpollArg: CustomStringConvertible {
        public let cursor : String
        public let timeout : UInt64
        public init(cursor: String, timeout: UInt64 = 30) {
            stringValidator()(value: cursor)
            self.cursor = cursor
            comparableValidator(minValue: 30, maxValue: 480)(value: timeout)
            self.timeout = timeout
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderLongpollArgSerializer().serialize(self)))"
        }
    }
    public class ListFolderLongpollArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFolderLongpollArg) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            "timeout": Serialization._UInt64Serializer.serialize(value.timeout),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListFolderLongpollArg {
            switch json {
                case .Dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .Null)
                    let timeout = Serialization._UInt64Serializer.deserialize(dict["timeout"] ?? .Null)
                    return ListFolderLongpollArg(cursor: cursor, timeout: timeout)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Information returned by `list_folder/longpoll`
    ///
    /// :param: changes
    ///        Indicates whether new changes are available. If true, call
    ///        `list_folder` to retrieve the changes.
    /// :param: backoff
    ///        If present, backoff for at least this many seconds before calling
    ///        `list_folder/longpoll` again.
    public class ListFolderLongpollResult: CustomStringConvertible {
        public let changes : Bool
        public let backoff : UInt64?
        public init(changes: Bool, backoff: UInt64? = nil) {
            self.changes = changes
            nullableValidator(comparableValidator())(value: backoff)
            self.backoff = backoff
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderLongpollResultSerializer().serialize(self)))"
        }
    }
    public class ListFolderLongpollResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFolderLongpollResult) -> JSON {
            let output = [ 
            "changes": Serialization._BoolSerializer.serialize(value.changes),
            "backoff": NullableSerializer(Serialization._UInt64Serializer).serialize(value.backoff),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListFolderLongpollResult {
            switch json {
                case .Dictionary(let dict):
                    let changes = Serialization._BoolSerializer.deserialize(dict["changes"] ?? .Null)
                    let backoff = NullableSerializer(Serialization._UInt64Serializer).deserialize(dict["backoff"] ?? .Null)
                    return ListFolderLongpollResult(changes: changes, backoff: backoff)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// The ListFolderLongpollError union
    ///
    /// - Reset:
    ///   Indicates that the cursor has been invalidated. Call `list_folder` to
    ///   obtain a new cursor.
    /// - Other
    public enum ListFolderLongpollError : CustomStringConvertible {
        case Reset
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderLongpollErrorSerializer().serialize(self)))"
        }
    }
    public class ListFolderLongpollErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFolderLongpollError) -> JSON {
            switch value {
                case .Reset:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("reset")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ListFolderLongpollError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "reset":
                            return ListFolderLongpollError.Reset
                        case "other":
                            return ListFolderLongpollError.Other
                        default:
                            return ListFolderLongpollError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Arguments for `list_folder`.
    ///
    /// :param: path
    ///        The path to the folder you want to see the contents of.
    /// :param: recursive
    ///        If true, list folder operation will be applied recursively to all
    ///        subfolders. And the response will contain contents of all
    ///        subfolders
    public class ListFolderArg: CustomStringConvertible {
        public let path : String
        public let recursive : Bool
        public init(path: String, recursive: Bool = false) {
            stringValidator(pattern: "(/.*)?")(value: path)
            self.path = path
            self.recursive = recursive
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderArgSerializer().serialize(self)))"
        }
    }
    public class ListFolderArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFolderArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "recursive": Serialization._BoolSerializer.serialize(value.recursive),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListFolderArg {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    let recursive = Serialization._BoolSerializer.deserialize(dict["recursive"] ?? .Null)
                    return ListFolderArg(path: path, recursive: recursive)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Information returned by `list_folder`.
    ///
    /// :param: entries
    ///        The files and (direct) subfolders in the folder.
    /// :param: cursor
    ///        Pass the cursor into `list_folder/continue` to see what's changed
    ///        in the folder since your previous query.
    /// :param: hasMore
    ///        If true, then there are more entries available. Pass the cursor
    ///        to `list_folder/continue` to retrieve the rest.
    public class ListFolderResult: CustomStringConvertible {
        public let entries : Array<Metadata>
        public let cursor : String
        public let hasMore : Bool
        public init(entries: Array<Metadata>, cursor: String, hasMore: Bool) {
            self.entries = entries
            stringValidator()(value: cursor)
            self.cursor = cursor
            self.hasMore = hasMore
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderResultSerializer().serialize(self)))"
        }
    }
    public class ListFolderResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFolderResult) -> JSON {
            let output = [ 
            "entries": ArraySerializer(MetadataSerializer()).serialize(value.entries),
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            "has_more": Serialization._BoolSerializer.serialize(value.hasMore),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListFolderResult {
            switch json {
                case .Dictionary(let dict):
                    let entries = ArraySerializer(MetadataSerializer()).deserialize(dict["entries"] ?? .Null)
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .Null)
                    let hasMore = Serialization._BoolSerializer.deserialize(dict["has_more"] ?? .Null)
                    return ListFolderResult(entries: entries, cursor: cursor, hasMore: hasMore)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Error returned by `list_folder` and `list_folder/continue`.
    ///
    /// - Path
    /// - Other:
    ///   An unspecified error.
    public enum ListFolderError : CustomStringConvertible {
        case Path(Files.LookupError)
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderErrorSerializer().serialize(self)))"
        }
    }
    public class ListFolderErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFolderError) -> JSON {
            switch value {
                case .Path(let arg):
                    var d = ["path": LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("path")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ListFolderError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = LookupErrorSerializer().deserialize(d["path"] ?? .Null)
                            return ListFolderError.Path(v)
                        case "other":
                            return ListFolderError.Other
                        default:
                            return ListFolderError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Arguments for `list_folder/continue`.
    ///
    /// :param: cursor
    ///        The cursor returned by `list_folder` or `list_folder/continue`.
    public class ListFolderContinueArg: CustomStringConvertible {
        public let cursor : String
        public init(cursor: String) {
            stringValidator()(value: cursor)
            self.cursor = cursor
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderContinueArgSerializer().serialize(self)))"
        }
    }
    public class ListFolderContinueArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFolderContinueArg) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListFolderContinueArg {
            switch json {
                case .Dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .Null)
                    return ListFolderContinueArg(cursor: cursor)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Error returned by `list_folder/continue`.
    ///
    /// - Path
    /// - Reset:
    ///   Indicates that the cursor has been invalidated. Call `list_folder` to
    ///   obtain a new cursor.
    /// - Other
    public enum ListFolderContinueError : CustomStringConvertible {
        case Path(Files.LookupError)
        case Reset
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderContinueErrorSerializer().serialize(self)))"
        }
    }
    public class ListFolderContinueErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFolderContinueError) -> JSON {
            switch value {
                case .Path(let arg):
                    var d = ["path": LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("path")
                    return .Dictionary(d)
                case .Reset:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("reset")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ListFolderContinueError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = LookupErrorSerializer().deserialize(d["path"] ?? .Null)
                            return ListFolderContinueError.Path(v)
                        case "reset":
                            return ListFolderContinueError.Reset
                        case "other":
                            return ListFolderContinueError.Other
                        default:
                            return ListFolderContinueError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Information returned by `list_folder/get_latest_cursor`.
    ///
    /// :param: cursor
    ///        Pass the cursor into `list_folder/continue` to see what's changed
    ///        in the folder since your previous query.
    public class ListFolderGetLatestCursorResult: CustomStringConvertible {
        public let cursor : String
        public init(cursor: String) {
            stringValidator()(value: cursor)
            self.cursor = cursor
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderGetLatestCursorResultSerializer().serialize(self)))"
        }
    }
    public class ListFolderGetLatestCursorResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListFolderGetLatestCursorResult) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListFolderGetLatestCursorResult {
            switch json {
                case .Dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .Null)
                    return ListFolderGetLatestCursorResult(cursor: cursor)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Errors from `download`.
    ///
    /// - Path
    /// - Other:
    ///   An unspecified error.
    public enum DownloadError : CustomStringConvertible {
        case Path(Files.LookupError)
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(DownloadErrorSerializer().serialize(self)))"
        }
    }
    public class DownloadErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: DownloadError) -> JSON {
            switch value {
                case .Path(let arg):
                    var d = ["path": LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("path")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> DownloadError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = LookupErrorSerializer().deserialize(d["path"] ?? .Null)
                            return DownloadError.Path(v)
                        case "other":
                            return DownloadError.Other
                        default:
                            return DownloadError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Arguments for `download`.
    ///
    /// :param: path
    ///        The path of the file to download.
    /// :param: rev
    ///        Optional revision, taken from the corresponding `Metadata` field.
    public class DownloadArg: CustomStringConvertible {
        public let path : String
        public let rev : String?
        public init(path: String, rev: String? = nil) {
            stringValidator(pattern: "/.*")(value: path)
            self.path = path
            nullableValidator(stringValidator(minLength: 9, pattern: "[0-9a-f]+"))(value: rev)
            self.rev = rev
        }
        public var description : String {
            return "\(prepareJSONForSerialization(DownloadArgSerializer().serialize(self)))"
        }
    }
    public class DownloadArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: DownloadArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "rev": NullableSerializer(Serialization._StringSerializer).serialize(value.rev),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> DownloadArg {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    let rev = NullableSerializer(Serialization._StringSerializer).deserialize(dict["rev"] ?? .Null)
                    return DownloadArg(path: path, rev: rev)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// The UploadWriteFailed struct
    ///
    /// :param: reason
    ///        The reason why the file couldn't be saved.
    /// :param: uploadSessionId
    ///        The upload session ID; this may be used to retry the commit.
    public class UploadWriteFailed: CustomStringConvertible {
        public let reason : WriteError
        public let uploadSessionId : String
        public init(reason: WriteError, uploadSessionId: String) {
            self.reason = reason
            stringValidator()(value: uploadSessionId)
            self.uploadSessionId = uploadSessionId
        }
        public var description : String {
            return "\(prepareJSONForSerialization(UploadWriteFailedSerializer().serialize(self)))"
        }
    }
    public class UploadWriteFailedSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UploadWriteFailed) -> JSON {
            let output = [ 
            "reason": WriteErrorSerializer().serialize(value.reason),
            "upload_session_id": Serialization._StringSerializer.serialize(value.uploadSessionId),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> UploadWriteFailed {
            switch json {
                case .Dictionary(let dict):
                    let reason = WriteErrorSerializer().deserialize(dict["reason"] ?? .Null)
                    let uploadSessionId = Serialization._StringSerializer.deserialize(dict["upload_session_id"] ?? .Null)
                    return UploadWriteFailed(reason: reason, uploadSessionId: uploadSessionId)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Errors for upload.
    ///
    /// - Path:
    ///   Unable to save the uploaded contents to a file.
    /// - Other:
    ///   An unspecified error.
    public enum UploadError : CustomStringConvertible {
        case Path(Files.UploadWriteFailed)
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(UploadErrorSerializer().serialize(self)))"
        }
    }
    public class UploadErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UploadError) -> JSON {
            switch value {
                case .Path(let arg):
                    var d = Serialization.getFields(UploadWriteFailedSerializer().serialize(arg))
                    d[".tag"] = .Str("path")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> UploadError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = UploadWriteFailedSerializer().deserialize(json)
                            return UploadError.Path(v)
                        case "other":
                            return UploadError.Other
                        default:
                            return UploadError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Error structure for recovering the correct upload offset.
    ///
    /// :param: correctOffset
    ///        The offset up to which data has been collected.
    public class UploadSessionOffsetError: CustomStringConvertible {
        public let correctOffset : UInt64
        public init(correctOffset: UInt64) {
            comparableValidator()(value: correctOffset)
            self.correctOffset = correctOffset
        }
        public var description : String {
            return "\(prepareJSONForSerialization(UploadSessionOffsetErrorSerializer().serialize(self)))"
        }
    }
    public class UploadSessionOffsetErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UploadSessionOffsetError) -> JSON {
            let output = [ 
            "correct_offset": Serialization._UInt64Serializer.serialize(value.correctOffset),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> UploadSessionOffsetError {
            switch json {
                case .Dictionary(let dict):
                    let correctOffset = Serialization._UInt64Serializer.deserialize(dict["correct_offset"] ?? .Null)
                    return UploadSessionOffsetError(correctOffset: correctOffset)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Errors related to upload sessions.
    ///
    /// - NotFound:
    ///   The upload session id was not found.
    /// - IncorrectOffset:
    ///   The specified offset was incorrect. See the value for the correct
    ///   offset. (This error may occur when a previous request was received and
    ///   processed successfully but the client did not receive the response,
    ///   e.g. due to a network error.)
    /// - Closed:
    ///   You are attempting to append data to an upload session that has alread
    ///   been closed (i.e. committed).
    /// - Other:
    ///   An unspecified error.
    public enum UploadSessionLookupError : CustomStringConvertible {
        case NotFound
        case IncorrectOffset(Files.UploadSessionOffsetError)
        case Closed
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(UploadSessionLookupErrorSerializer().serialize(self)))"
        }
    }
    public class UploadSessionLookupErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UploadSessionLookupError) -> JSON {
            switch value {
                case .NotFound:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("not_found")
                    return .Dictionary(d)
                case .IncorrectOffset(let arg):
                    var d = Serialization.getFields(UploadSessionOffsetErrorSerializer().serialize(arg))
                    d[".tag"] = .Str("incorrect_offset")
                    return .Dictionary(d)
                case .Closed:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("closed")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> UploadSessionLookupError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "not_found":
                            return UploadSessionLookupError.NotFound
                        case "incorrect_offset":
                            let v = UploadSessionOffsetErrorSerializer().deserialize(json)
                            return UploadSessionLookupError.IncorrectOffset(v)
                        case "closed":
                            return UploadSessionLookupError.Closed
                        case "other":
                            return UploadSessionLookupError.Other
                        default:
                            return UploadSessionLookupError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Errors for `upload_session/finish`.
    ///
    /// - LookupFailed:
    ///   The session arguments are incorrect; the value explains the reason.
    /// - Path:
    ///   Unable to save the uploaded contents to a file.
    /// - Other:
    ///   An unspecified error.
    public enum UploadSessionFinishError : CustomStringConvertible {
        case LookupFailed(Files.UploadSessionLookupError)
        case Path(Files.WriteError)
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(UploadSessionFinishErrorSerializer().serialize(self)))"
        }
    }
    public class UploadSessionFinishErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UploadSessionFinishError) -> JSON {
            switch value {
                case .LookupFailed(let arg):
                    var d = ["lookup_failed": UploadSessionLookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("lookup_failed")
                    return .Dictionary(d)
                case .Path(let arg):
                    var d = ["path": WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("path")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> UploadSessionFinishError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "lookup_failed":
                            let v = UploadSessionLookupErrorSerializer().deserialize(d["lookup_failed"] ?? .Null)
                            return UploadSessionFinishError.LookupFailed(v)
                        case "path":
                            let v = WriteErrorSerializer().deserialize(d["path"] ?? .Null)
                            return UploadSessionFinishError.Path(v)
                        case "other":
                            return UploadSessionFinishError.Other
                        default:
                            return UploadSessionFinishError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// The result of `upload_session/start`.
    ///
    /// :param: sessionId
    ///        A unique identifier for the upload session. Pass this to
    ///        `upload_session/append` and `upload_session/finish`.
    public class UploadSessionStartResult: CustomStringConvertible {
        public let sessionId : String
        public init(sessionId: String) {
            stringValidator()(value: sessionId)
            self.sessionId = sessionId
        }
        public var description : String {
            return "\(prepareJSONForSerialization(UploadSessionStartResultSerializer().serialize(self)))"
        }
    }
    public class UploadSessionStartResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UploadSessionStartResult) -> JSON {
            let output = [ 
            "session_id": Serialization._StringSerializer.serialize(value.sessionId),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> UploadSessionStartResult {
            switch json {
                case .Dictionary(let dict):
                    let sessionId = Serialization._StringSerializer.deserialize(dict["session_id"] ?? .Null)
                    return UploadSessionStartResult(sessionId: sessionId)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Arguments for `upload_session/append`. Also used by
    /// `upload_session/finish`.
    ///
    /// :param: sessionId
    ///        The upload session ID (returned by `upload_session/start`).
    /// :param: offset
    ///        The amount of data that has been uploaded so far. We use this to
    ///        make sure upload data isn't lost or duplicated in the event of a
    ///        network error.
    public class UploadSessionCursor: CustomStringConvertible {
        public let sessionId : String
        public let offset : UInt64
        public init(sessionId: String, offset: UInt64) {
            stringValidator()(value: sessionId)
            self.sessionId = sessionId
            comparableValidator()(value: offset)
            self.offset = offset
        }
        public var description : String {
            return "\(prepareJSONForSerialization(UploadSessionCursorSerializer().serialize(self)))"
        }
    }
    public class UploadSessionCursorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UploadSessionCursor) -> JSON {
            let output = [ 
            "session_id": Serialization._StringSerializer.serialize(value.sessionId),
            "offset": Serialization._UInt64Serializer.serialize(value.offset),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> UploadSessionCursor {
            switch json {
                case .Dictionary(let dict):
                    let sessionId = Serialization._StringSerializer.deserialize(dict["session_id"] ?? .Null)
                    let offset = Serialization._UInt64Serializer.deserialize(dict["offset"] ?? .Null)
                    return UploadSessionCursor(sessionId: sessionId, offset: offset)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Your intent when writing a file to some path. This is used to determine
    /// what constitutes a conflict and what the autorename strategy is. In some
    /// situations, the conflict behavior is identical: (a) If the target path
    /// doesn't contain anything, the file is always written; no conflict. (b)
    /// If the target path contains a folder, it's always a conflict. (c) If the
    /// target path contains a file with identical contents, nothing gets
    /// written; no conflict. The conflict checking differs in the case where
    /// there's a file at the target path with contents different from the
    /// contents you're trying to write.
    ///
    /// - Add:
    ///   It's always a conflict. The autorename strategy is to append a number
    ///   to the file name. For example "document.txt" might become "document
    ///   (2).txt".
    /// - Overwrite:
    ///   It's never a conflict. Overwrite the existing file. The autorename
    ///   strategy is the same as it is for `add`.
    /// - Update:
    ///   It's a conflict only if the current "rev" doesn't match the given
    ///   "rev". The autorename strategy is to append the string "conflicted
    ///   copy" to the file name. For example, "document.txt" might become
    ///   "document (conflicted copy).txt" or "document (Panda's conflicted
    ///   copy).txt".
    public enum WriteMode : CustomStringConvertible {
        case Add
        case Overwrite
        case Update(String)
        public var description : String {
            return "\(prepareJSONForSerialization(WriteModeSerializer().serialize(self)))"
        }
    }
    public class WriteModeSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: WriteMode) -> JSON {
            switch value {
                case .Add:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("add")
                    return .Dictionary(d)
                case .Overwrite:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("overwrite")
                    return .Dictionary(d)
                case .Update(let arg):
                    var d = ["update": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .Str("update")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> WriteMode {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "add":
                            return WriteMode.Add
                        case "overwrite":
                            return WriteMode.Overwrite
                        case "update":
                            let v = Serialization._StringSerializer.deserialize(d["update"] ?? .Null)
                            return WriteMode.Update(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Arguments for `upload`. Also part of the arguments to
    /// `upload_session/finish`.
    ///
    /// :param: path
    ///        Path in the user's Dropbox to save the file.
    /// :param: mode
    ///        Selects what to do if the file already exists.
    /// :param: autorename
    ///        If there's a conflict, as determined by `mode`, have the Dropbox
    ///        server try to autorename the file to avoid conflict.
    /// :param: clientModified
    ///        The value to store as the `client_modified` timestamp. Dropbox
    ///        automatically records the time at which the file was written to
    ///        the Dropbox servers. It can also record an additional timestamp,
    ///        provided by Dropbox desktop clients, mobile clients, and API apps
    ///        of when the file was actually created or modified.
    /// :param: mute
    ///        Normally, users are made aware of any file modifications in their
    ///        Dropbox account via notifications in the client software. If
    ///        `true`, this tells the clients that this modification shouldn't
    ///        result in a user notification.
    public class CommitInfo: CustomStringConvertible {
        public let path : String
        public let mode : WriteMode
        public let autorename : Bool
        public let clientModified : NSDate?
        public let mute : Bool
        public init(path: String, mode: WriteMode = .Add, autorename: Bool = false, clientModified: NSDate? = nil, mute: Bool = false) {
            stringValidator(pattern: "/.*")(value: path)
            self.path = path
            self.mode = mode
            self.autorename = autorename
            self.clientModified = clientModified
            self.mute = mute
        }
        public var description : String {
            return "\(prepareJSONForSerialization(CommitInfoSerializer().serialize(self)))"
        }
    }
    public class CommitInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: CommitInfo) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "mode": WriteModeSerializer().serialize(value.mode),
            "autorename": Serialization._BoolSerializer.serialize(value.autorename),
            "client_modified": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.clientModified),
            "mute": Serialization._BoolSerializer.serialize(value.mute),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> CommitInfo {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    let mode = WriteModeSerializer().deserialize(dict["mode"] ?? .Null)
                    let autorename = Serialization._BoolSerializer.deserialize(dict["autorename"] ?? .Null)
                    let clientModified = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["client_modified"] ?? .Null)
                    let mute = Serialization._BoolSerializer.deserialize(dict["mute"] ?? .Null)
                    return CommitInfo(path: path, mode: mode, autorename: autorename, clientModified: clientModified, mute: mute)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Arguments for `upload_session/finish`.
    ///
    /// :param: cursor
    ///        Contains the upload session ID and the offset.
    /// :param: commit
    ///        Contains the path and other optional modifiers for the commit.
    public class UploadSessionFinishArg: CustomStringConvertible {
        public let cursor : UploadSessionCursor
        public let commit : CommitInfo
        public init(cursor: UploadSessionCursor, commit: CommitInfo) {
            self.cursor = cursor
            self.commit = commit
        }
        public var description : String {
            return "\(prepareJSONForSerialization(UploadSessionFinishArgSerializer().serialize(self)))"
        }
    }
    public class UploadSessionFinishArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: UploadSessionFinishArg) -> JSON {
            let output = [ 
            "cursor": UploadSessionCursorSerializer().serialize(value.cursor),
            "commit": CommitInfoSerializer().serialize(value.commit),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> UploadSessionFinishArg {
            switch json {
                case .Dictionary(let dict):
                    let cursor = UploadSessionCursorSerializer().deserialize(dict["cursor"] ?? .Null)
                    let commit = CommitInfoSerializer().deserialize(dict["commit"] ?? .Null)
                    return UploadSessionFinishArg(cursor: cursor, commit: commit)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Select which type of data to search.
    ///
    /// - Filename:
    ///   Search file and folder names.
    /// - FilenameAndContent:
    ///   Search file and folder names as well as file contents.
    /// - DeletedFilename:
    ///   Search for deleted file and folder names.
    public enum SearchMode : CustomStringConvertible {
        case Filename
        case FilenameAndContent
        case DeletedFilename
        public var description : String {
            return "\(prepareJSONForSerialization(SearchModeSerializer().serialize(self)))"
        }
    }
    public class SearchModeSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SearchMode) -> JSON {
            switch value {
                case .Filename:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("filename")
                    return .Dictionary(d)
                case .FilenameAndContent:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("filename_and_content")
                    return .Dictionary(d)
                case .DeletedFilename:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("deleted_filename")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> SearchMode {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "filename":
                            return SearchMode.Filename
                        case "filename_and_content":
                            return SearchMode.FilenameAndContent
                        case "deleted_filename":
                            return SearchMode.DeletedFilename
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Arguments for `search`.
    ///
    /// :param: path
    ///        The path in the user's Dropbox to search. Should probably be a
    ///        folder.
    /// :param: query
    ///        The string to search for. The search string is split on spaces
    ///        into multiple tokens. For file name searching, the last token is
    ///        used for prefix matching (i.e. "bat c" matches "bat cave" but not
    ///        "batman car").
    /// :param: start
    ///        The starting index within the search results (used for paging).
    /// :param: maxResults
    ///        The maximum number of search results to return.
    /// :param: mode
    ///        The search mode (filename, filename_and_content, or
    ///        deleted_filename).
    public class SearchQuery: CustomStringConvertible {
        public let path : String
        public let query : String
        public let start : UInt64
        public let maxResults : UInt64
        public let mode : SearchMode
        public init(path: String, query: String, start: UInt64 = 0, maxResults: UInt64 = 100, mode: SearchMode = .Filename) {
            stringValidator(pattern: "(/.*)?")(value: path)
            self.path = path
            stringValidator()(value: query)
            self.query = query
            comparableValidator()(value: start)
            self.start = start
            comparableValidator(minValue: 1, maxValue: 1000)(value: maxResults)
            self.maxResults = maxResults
            self.mode = mode
        }
        public var description : String {
            return "\(prepareJSONForSerialization(SearchQuerySerializer().serialize(self)))"
        }
    }
    public class SearchQuerySerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SearchQuery) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "query": Serialization._StringSerializer.serialize(value.query),
            "start": Serialization._UInt64Serializer.serialize(value.start),
            "max_results": Serialization._UInt64Serializer.serialize(value.maxResults),
            "mode": SearchModeSerializer().serialize(value.mode),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> SearchQuery {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    let query = Serialization._StringSerializer.deserialize(dict["query"] ?? .Null)
                    let start = Serialization._UInt64Serializer.deserialize(dict["start"] ?? .Null)
                    let maxResults = Serialization._UInt64Serializer.deserialize(dict["max_results"] ?? .Null)
                    let mode = SearchModeSerializer().deserialize(dict["mode"] ?? .Null)
                    return SearchQuery(path: path, query: query, start: start, maxResults: maxResults, mode: mode)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Indicates what type of match was found for a given item.
    ///
    /// - Filename:
    ///   This item was matched on its file or folder name.
    /// - Content:
    ///   This item was matched based on its file contents.
    /// - Both:
    ///   This item was matched based on both its contents and its file name.
    public enum SearchMatchType : CustomStringConvertible {
        case Filename
        case Content
        case Both
        public var description : String {
            return "\(prepareJSONForSerialization(SearchMatchTypeSerializer().serialize(self)))"
        }
    }
    public class SearchMatchTypeSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SearchMatchType) -> JSON {
            switch value {
                case .Filename:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("filename")
                    return .Dictionary(d)
                case .Content:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("content")
                    return .Dictionary(d)
                case .Both:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("both")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> SearchMatchType {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "filename":
                            return SearchMatchType.Filename
                        case "content":
                            return SearchMatchType.Content
                        case "both":
                            return SearchMatchType.Both
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Describes a search result.
    ///
    /// :param: matchType
    ///        The type of the match.
    /// :param: metadata
    ///        The metadata for the matched file or folder.
    public class SearchMatch: CustomStringConvertible {
        public let matchType : SearchMatchType
        public let metadata : Metadata
        public init(matchType: SearchMatchType, metadata: Metadata) {
            self.matchType = matchType
            self.metadata = metadata
        }
        public var description : String {
            return "\(prepareJSONForSerialization(SearchMatchSerializer().serialize(self)))"
        }
    }
    public class SearchMatchSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SearchMatch) -> JSON {
            let output = [ 
            "match_type": SearchMatchTypeSerializer().serialize(value.matchType),
            "metadata": MetadataSerializer().serialize(value.metadata),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> SearchMatch {
            switch json {
                case .Dictionary(let dict):
                    let matchType = SearchMatchTypeSerializer().deserialize(dict["match_type"] ?? .Null)
                    let metadata = MetadataSerializer().deserialize(dict["metadata"] ?? .Null)
                    return SearchMatch(matchType: matchType, metadata: metadata)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Information returned by `search`.
    ///
    /// :param: matches
    ///        A list (possibly empty) of matches for the query.
    /// :param: more
    ///        Used for paging. If true, indicates there is another page of
    ///        results available that can be fetched by calling `search` again.
    /// :param: start
    ///        Used for paging. Value to set the start argument to when calling
    ///        `search` to fetch the next page of results.
    public class SearchResults: CustomStringConvertible {
        public let matches : Array<SearchMatch>
        public let more : Bool
        public let start : UInt64
        public init(matches: Array<SearchMatch>, more: Bool, start: UInt64) {
            self.matches = matches
            self.more = more
            comparableValidator()(value: start)
            self.start = start
        }
        public var description : String {
            return "\(prepareJSONForSerialization(SearchResultsSerializer().serialize(self)))"
        }
    }
    public class SearchResultsSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SearchResults) -> JSON {
            let output = [ 
            "matches": ArraySerializer(SearchMatchSerializer()).serialize(value.matches),
            "more": Serialization._BoolSerializer.serialize(value.more),
            "start": Serialization._UInt64Serializer.serialize(value.start),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> SearchResults {
            switch json {
                case .Dictionary(let dict):
                    let matches = ArraySerializer(SearchMatchSerializer()).deserialize(dict["matches"] ?? .Null)
                    let more = Serialization._BoolSerializer.deserialize(dict["more"] ?? .Null)
                    let start = Serialization._UInt64Serializer.deserialize(dict["start"] ?? .Null)
                    return SearchResults(matches: matches, more: more, start: start)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Errors for `search`.
    ///
    /// - Path
    /// - Other:
    ///   An unspecified error.
    public enum SearchError : CustomStringConvertible {
        case Path(Files.LookupError)
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(SearchErrorSerializer().serialize(self)))"
        }
    }
    public class SearchErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: SearchError) -> JSON {
            switch value {
                case .Path(let arg):
                    var d = ["path": LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("path")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> SearchError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = LookupErrorSerializer().deserialize(d["path"] ?? .Null)
                            return SearchError.Path(v)
                        case "other":
                            return SearchError.Other
                        default:
                            return SearchError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// The LookupError union
    ///
    /// - MalformedPath
    /// - NotFound:
    ///   There is nothing at the given path.
    /// - NotFile:
    ///   We were expecting a file, but the given path refers to something that
    ///   isn't a file.
    /// - NotFolder:
    ///   We were expecting a folder, but the given path refers to something
    ///   that isn't a folder.
    /// - RestrictedContent:
    ///   The file cannot be transferred because the content is restricted.  For
    ///   example, sometimes there are legal restrictions due to copyright
    ///   claims.
    /// - Other
    public enum LookupError : CustomStringConvertible {
        case MalformedPath(String?)
        case NotFound
        case NotFile
        case NotFolder
        case RestrictedContent
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(LookupErrorSerializer().serialize(self)))"
        }
    }
    public class LookupErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: LookupError) -> JSON {
            switch value {
                case .MalformedPath(let arg):
                    var d = ["malformed_path": NullableSerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .Str("malformed_path")
                    return .Dictionary(d)
                case .NotFound:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("not_found")
                    return .Dictionary(d)
                case .NotFile:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("not_file")
                    return .Dictionary(d)
                case .NotFolder:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("not_folder")
                    return .Dictionary(d)
                case .RestrictedContent:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("restricted_content")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> LookupError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "malformed_path":
                            let v = Serialization._StringSerializer.deserialize(d["malformed_path"] ?? .Null)
                            return LookupError.MalformedPath(v)
                        case "not_found":
                            return LookupError.NotFound
                        case "not_file":
                            return LookupError.NotFile
                        case "not_folder":
                            return LookupError.NotFolder
                        case "restricted_content":
                            return LookupError.RestrictedContent
                        case "other":
                            return LookupError.Other
                        default:
                            return LookupError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// The WriteError union
    ///
    /// - MalformedPath
    /// - Conflict:
    ///   Couldn't write to the target path because there was something in the
    ///   way.
    /// - NoWritePermission:
    ///   The user doesn't have permissions to write to the target location.
    /// - InsufficientSpace:
    ///   The user doesn't have enough available space (bytes) to write more
    ///   data.
    /// - DisallowedName:
    ///   Dropbox will not save the file or folder because it of its name.
    /// - Other
    public enum WriteError : CustomStringConvertible {
        case MalformedPath(String?)
        case Conflict(Files.WriteConflictError)
        case NoWritePermission
        case InsufficientSpace
        case DisallowedName
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(WriteErrorSerializer().serialize(self)))"
        }
    }
    public class WriteErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: WriteError) -> JSON {
            switch value {
                case .MalformedPath(let arg):
                    var d = ["malformed_path": NullableSerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .Str("malformed_path")
                    return .Dictionary(d)
                case .Conflict(let arg):
                    var d = ["conflict": WriteConflictErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("conflict")
                    return .Dictionary(d)
                case .NoWritePermission:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("no_write_permission")
                    return .Dictionary(d)
                case .InsufficientSpace:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("insufficient_space")
                    return .Dictionary(d)
                case .DisallowedName:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("disallowed_name")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> WriteError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "malformed_path":
                            let v = Serialization._StringSerializer.deserialize(d["malformed_path"] ?? .Null)
                            return WriteError.MalformedPath(v)
                        case "conflict":
                            let v = WriteConflictErrorSerializer().deserialize(d["conflict"] ?? .Null)
                            return WriteError.Conflict(v)
                        case "no_write_permission":
                            return WriteError.NoWritePermission
                        case "insufficient_space":
                            return WriteError.InsufficientSpace
                        case "disallowed_name":
                            return WriteError.DisallowedName
                        case "other":
                            return WriteError.Other
                        default:
                            return WriteError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// The WriteConflictError union
    ///
    /// - File:
    ///   There's a file in the way.
    /// - Folder:
    ///   There's a folder in the way.
    /// - FileAncestor:
    ///   There's a file at an ancestor path, so we couldn't create the required
    ///   parent folders.
    /// - Other
    public enum WriteConflictError : CustomStringConvertible {
        case File
        case Folder
        case FileAncestor
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(WriteConflictErrorSerializer().serialize(self)))"
        }
    }
    public class WriteConflictErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: WriteConflictError) -> JSON {
            switch value {
                case .File:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("file")
                    return .Dictionary(d)
                case .Folder:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("folder")
                    return .Dictionary(d)
                case .FileAncestor:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("file_ancestor")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> WriteConflictError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "file":
                            return WriteConflictError.File
                        case "folder":
                            return WriteConflictError.Folder
                        case "file_ancestor":
                            return WriteConflictError.FileAncestor
                        case "other":
                            return WriteConflictError.Other
                        default:
                            return WriteConflictError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Arguments for `create_folder`.
    ///
    /// :param: path
    ///        Path in the user's Dropbox to create.
    public class CreateFolderArg: CustomStringConvertible {
        public let path : String
        public init(path: String) {
            stringValidator(pattern: "/.*")(value: path)
            self.path = path
        }
        public var description : String {
            return "\(prepareJSONForSerialization(CreateFolderArgSerializer().serialize(self)))"
        }
    }
    public class CreateFolderArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: CreateFolderArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> CreateFolderArg {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    return CreateFolderArg(path: path)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// The CreateFolderError union
    ///
    /// - Path
    public enum CreateFolderError : CustomStringConvertible {
        case Path(Files.WriteError)
        public var description : String {
            return "\(prepareJSONForSerialization(CreateFolderErrorSerializer().serialize(self)))"
        }
    }
    public class CreateFolderErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: CreateFolderError) -> JSON {
            switch value {
                case .Path(let arg):
                    var d = ["path": WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("path")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> CreateFolderError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = WriteErrorSerializer().deserialize(d["path"] ?? .Null)
                            return CreateFolderError.Path(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Arguments for `delete`.
    ///
    /// :param: path
    ///        Path in the user's Dropbox to delete.
    public class DeleteArg: CustomStringConvertible {
        public let path : String
        public init(path: String) {
            stringValidator(pattern: "/.*")(value: path)
            self.path = path
        }
        public var description : String {
            return "\(prepareJSONForSerialization(DeleteArgSerializer().serialize(self)))"
        }
    }
    public class DeleteArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: DeleteArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> DeleteArg {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    return DeleteArg(path: path)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// The DeleteError union
    ///
    /// - PathLookup
    /// - PathWrite
    /// - Other
    public enum DeleteError : CustomStringConvertible {
        case PathLookup(Files.LookupError)
        case PathWrite(Files.WriteError)
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(DeleteErrorSerializer().serialize(self)))"
        }
    }
    public class DeleteErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: DeleteError) -> JSON {
            switch value {
                case .PathLookup(let arg):
                    var d = ["path_lookup": LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("path_lookup")
                    return .Dictionary(d)
                case .PathWrite(let arg):
                    var d = ["path_write": WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("path_write")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> DeleteError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path_lookup":
                            let v = LookupErrorSerializer().deserialize(d["path_lookup"] ?? .Null)
                            return DeleteError.PathLookup(v)
                        case "path_write":
                            let v = WriteErrorSerializer().deserialize(d["path_write"] ?? .Null)
                            return DeleteError.PathWrite(v)
                        case "other":
                            return DeleteError.Other
                        default:
                            return DeleteError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Arguments for `copy` and `move`.
    ///
    /// :param: fromPath
    ///        Path in the user's Dropbox to be copied or moved.
    /// :param: toPath
    ///        Path in the user's Dropbox that is the destination.
    public class RelocationArg: CustomStringConvertible {
        public let fromPath : String
        public let toPath : String
        public init(fromPath: String, toPath: String) {
            stringValidator(pattern: "/.*")(value: fromPath)
            self.fromPath = fromPath
            stringValidator(pattern: "/.*")(value: toPath)
            self.toPath = toPath
        }
        public var description : String {
            return "\(prepareJSONForSerialization(RelocationArgSerializer().serialize(self)))"
        }
    }
    public class RelocationArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RelocationArg) -> JSON {
            let output = [ 
            "from_path": Serialization._StringSerializer.serialize(value.fromPath),
            "to_path": Serialization._StringSerializer.serialize(value.toPath),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> RelocationArg {
            switch json {
                case .Dictionary(let dict):
                    let fromPath = Serialization._StringSerializer.deserialize(dict["from_path"] ?? .Null)
                    let toPath = Serialization._StringSerializer.deserialize(dict["to_path"] ?? .Null)
                    return RelocationArg(fromPath: fromPath, toPath: toPath)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Errors reported by `copy` and `move`.
    ///
    /// - FromLookup
    /// - FromWrite
    /// - To
    /// - CantCopySharedFolder:
    ///   Shared folders can't be copied.
    /// - CantNestSharedFolder:
    ///   Your move operation would result in nested shared folders.  This is
    ///   not allowed.
    /// - TooManyFiles:
    ///   The operation would involve more than 10,000 files and folders.
    /// - Other:
    ///   An unspecified error.
    public enum RelocationError : CustomStringConvertible {
        case FromLookup(Files.LookupError)
        case FromWrite(Files.WriteError)
        case To(Files.WriteError)
        case CantCopySharedFolder
        case CantNestSharedFolder
        case TooManyFiles
        case Other
        public var description : String {
            return "\(prepareJSONForSerialization(RelocationErrorSerializer().serialize(self)))"
        }
    }
    public class RelocationErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RelocationError) -> JSON {
            switch value {
                case .FromLookup(let arg):
                    var d = ["from_lookup": LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("from_lookup")
                    return .Dictionary(d)
                case .FromWrite(let arg):
                    var d = ["from_write": WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("from_write")
                    return .Dictionary(d)
                case .To(let arg):
                    var d = ["to": WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("to")
                    return .Dictionary(d)
                case .CantCopySharedFolder:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("cant_copy_shared_folder")
                    return .Dictionary(d)
                case .CantNestSharedFolder:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("cant_nest_shared_folder")
                    return .Dictionary(d)
                case .TooManyFiles:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("too_many_files")
                    return .Dictionary(d)
                case .Other:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("other")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> RelocationError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "from_lookup":
                            let v = LookupErrorSerializer().deserialize(d["from_lookup"] ?? .Null)
                            return RelocationError.FromLookup(v)
                        case "from_write":
                            let v = WriteErrorSerializer().deserialize(d["from_write"] ?? .Null)
                            return RelocationError.FromWrite(v)
                        case "to":
                            let v = WriteErrorSerializer().deserialize(d["to"] ?? .Null)
                            return RelocationError.To(v)
                        case "cant_copy_shared_folder":
                            return RelocationError.CantCopySharedFolder
                        case "cant_nest_shared_folder":
                            return RelocationError.CantNestSharedFolder
                        case "too_many_files":
                            return RelocationError.TooManyFiles
                        case "other":
                            return RelocationError.Other
                        default:
                            return RelocationError.Other
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// The ThumbnailSize union
    ///
    /// - W32h32:
    ///   32 by 32 px.
    /// - W64h64:
    ///   64 by 64 px.
    /// - W128h128:
    ///   128 by 128 px.
    /// - W640h480:
    ///   640 by 480 px.
    /// - W1024h768:
    ///   1024 by 768
    public enum ThumbnailSize : CustomStringConvertible {
        case W32h32
        case W64h64
        case W128h128
        case W640h480
        case W1024h768
        public var description : String {
            return "\(prepareJSONForSerialization(ThumbnailSizeSerializer().serialize(self)))"
        }
    }
    public class ThumbnailSizeSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ThumbnailSize) -> JSON {
            switch value {
                case .W32h32:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("w32h32")
                    return .Dictionary(d)
                case .W64h64:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("w64h64")
                    return .Dictionary(d)
                case .W128h128:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("w128h128")
                    return .Dictionary(d)
                case .W640h480:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("w640h480")
                    return .Dictionary(d)
                case .W1024h768:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("w1024h768")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ThumbnailSize {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "w32h32":
                            return ThumbnailSize.W32h32
                        case "w64h64":
                            return ThumbnailSize.W64h64
                        case "w128h128":
                            return ThumbnailSize.W128h128
                        case "w640h480":
                            return ThumbnailSize.W640h480
                        case "w1024h768":
                            return ThumbnailSize.W1024h768
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// The ThumbnailFormat union
    ///
    /// - Jpeg
    /// - Png
    public enum ThumbnailFormat : CustomStringConvertible {
        case Jpeg
        case Png
        public var description : String {
            return "\(prepareJSONForSerialization(ThumbnailFormatSerializer().serialize(self)))"
        }
    }
    public class ThumbnailFormatSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ThumbnailFormat) -> JSON {
            switch value {
                case .Jpeg:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("jpeg")
                    return .Dictionary(d)
                case .Png:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("png")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ThumbnailFormat {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "jpeg":
                            return ThumbnailFormat.Jpeg
                        case "png":
                            return ThumbnailFormat.Png
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// The ThumbnailArg struct
    ///
    /// :param: path
    ///        The path to the image file you want to thumbnail.
    /// :param: format
    ///        The format for the thumbnail image, jpeg (default) or png. For
    ///        images that are photos, jpeg should be preferred, while png is
    ///        better for screenshots and digital arts.
    /// :param: size
    ///        The size for the thumbnail image.
    public class ThumbnailArg: CustomStringConvertible {
        public let path : String
        public let format : ThumbnailFormat
        public let size : ThumbnailSize
        public init(path: String, format: ThumbnailFormat = .Jpeg, size: ThumbnailSize = .W64h64) {
            stringValidator(pattern: "/.*")(value: path)
            self.path = path
            self.format = format
            self.size = size
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ThumbnailArgSerializer().serialize(self)))"
        }
    }
    public class ThumbnailArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ThumbnailArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "format": ThumbnailFormatSerializer().serialize(value.format),
            "size": ThumbnailSizeSerializer().serialize(value.size),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ThumbnailArg {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    let format = ThumbnailFormatSerializer().deserialize(dict["format"] ?? .Null)
                    let size = ThumbnailSizeSerializer().deserialize(dict["size"] ?? .Null)
                    return ThumbnailArg(path: path, format: format, size: size)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// The ThumbnailError union
    ///
    /// - Path:
    ///   An error occurs when downloading metadata for the image.
    /// - UnsupportedExtension:
    ///   The file extension doesn't allow conversion to a thumbnail.
    /// - UnsupportedImage:
    ///   The image cannot be converted to a thumbnail.
    /// - ConversionError:
    ///   An error occurs during thumbnail conversion.
    public enum ThumbnailError : CustomStringConvertible {
        case Path(Files.LookupError)
        case UnsupportedExtension
        case UnsupportedImage
        case ConversionError
        public var description : String {
            return "\(prepareJSONForSerialization(ThumbnailErrorSerializer().serialize(self)))"
        }
    }
    public class ThumbnailErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ThumbnailError) -> JSON {
            switch value {
                case .Path(let arg):
                    var d = ["path": LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("path")
                    return .Dictionary(d)
                case .UnsupportedExtension:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("unsupported_extension")
                    return .Dictionary(d)
                case .UnsupportedImage:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("unsupported_image")
                    return .Dictionary(d)
                case .ConversionError:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("conversion_error")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ThumbnailError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = LookupErrorSerializer().deserialize(d["path"] ?? .Null)
                            return ThumbnailError.Path(v)
                        case "unsupported_extension":
                            return ThumbnailError.UnsupportedExtension
                        case "unsupported_image":
                            return ThumbnailError.UnsupportedImage
                        case "conversion_error":
                            return ThumbnailError.ConversionError
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Arguments for `get_preview`.
    ///
    /// :param: path
    ///        The path of the file to preview.
    /// :param: rev
    ///        Optional revision, taken from the corresponding `Metadata` field.
    public class PreviewArg: CustomStringConvertible {
        public let path : String
        public let rev : String?
        public init(path: String, rev: String? = nil) {
            stringValidator(pattern: "/.*")(value: path)
            self.path = path
            nullableValidator(stringValidator(minLength: 9, pattern: "[0-9a-f]+"))(value: rev)
            self.rev = rev
        }
        public var description : String {
            return "\(prepareJSONForSerialization(PreviewArgSerializer().serialize(self)))"
        }
    }
    public class PreviewArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: PreviewArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "rev": NullableSerializer(Serialization._StringSerializer).serialize(value.rev),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> PreviewArg {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    let rev = NullableSerializer(Serialization._StringSerializer).deserialize(dict["rev"] ?? .Null)
                    return PreviewArg(path: path, rev: rev)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Errors reported by `get_preview`.
    ///
    /// - Path:
    ///   An error occurs when downloading metadata for the file.
    /// - InProgress:
    ///   This preview generation is still in progress and the file is not ready
    ///   for preview yet.
    /// - UnsupportedExtension:
    ///   The file extension is not supported preview generation.
    /// - UnsupportedContent:
    ///   The file content is not supported for preview generation.
    public enum PreviewError : CustomStringConvertible {
        case Path(Files.LookupError)
        case InProgress
        case UnsupportedExtension
        case UnsupportedContent
        public var description : String {
            return "\(prepareJSONForSerialization(PreviewErrorSerializer().serialize(self)))"
        }
    }
    public class PreviewErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: PreviewError) -> JSON {
            switch value {
                case .Path(let arg):
                    var d = ["path": LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("path")
                    return .Dictionary(d)
                case .InProgress:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("in_progress")
                    return .Dictionary(d)
                case .UnsupportedExtension:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("unsupported_extension")
                    return .Dictionary(d)
                case .UnsupportedContent:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("unsupported_content")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> PreviewError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = LookupErrorSerializer().deserialize(d["path"] ?? .Null)
                            return PreviewError.Path(v)
                        case "in_progress":
                            return PreviewError.InProgress
                        case "unsupported_extension":
                            return PreviewError.UnsupportedExtension
                        case "unsupported_content":
                            return PreviewError.UnsupportedContent
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Arguments for `list_revisions`.
    ///
    /// :param: path
    ///        The path to the file you want to see the revisions of.
    /// :param: limit
    ///        The maximum number of revision entries returned.
    public class ListRevisionsArg: CustomStringConvertible {
        public let path : String
        public let limit : UInt64
        public init(path: String, limit: UInt64 = 10) {
            stringValidator(pattern: "/.*")(value: path)
            self.path = path
            comparableValidator(minValue: 1, maxValue: 100)(value: limit)
            self.limit = limit
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ListRevisionsArgSerializer().serialize(self)))"
        }
    }
    public class ListRevisionsArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListRevisionsArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "limit": Serialization._UInt64Serializer.serialize(value.limit),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListRevisionsArg {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    let limit = Serialization._UInt64Serializer.deserialize(dict["limit"] ?? .Null)
                    return ListRevisionsArg(path: path, limit: limit)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Errors reported by `list_revisions`.
    ///
    /// - Path
    public enum ListRevisionsError : CustomStringConvertible {
        case Path(Files.LookupError)
        public var description : String {
            return "\(prepareJSONForSerialization(ListRevisionsErrorSerializer().serialize(self)))"
        }
    }
    public class ListRevisionsErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListRevisionsError) -> JSON {
            switch value {
                case .Path(let arg):
                    var d = ["path": LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("path")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> ListRevisionsError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = LookupErrorSerializer().deserialize(d["path"] ?? .Null)
                            return ListRevisionsError.Path(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
    /// Information returned by `list_revisions`.
    ///
    /// :param: isDeleted
    ///        If the file is deleted.
    /// :param: entries
    ///        The revisions for the file. Only non-delete revisions will show
    ///        up here.
    public class ListRevisionsResult: CustomStringConvertible {
        public let isDeleted : Bool
        public let entries : Array<FileMetadata>
        public init(isDeleted: Bool, entries: Array<FileMetadata>) {
            self.isDeleted = isDeleted
            self.entries = entries
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ListRevisionsResultSerializer().serialize(self)))"
        }
    }
    public class ListRevisionsResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: ListRevisionsResult) -> JSON {
            let output = [ 
            "is_deleted": Serialization._BoolSerializer.serialize(value.isDeleted),
            "entries": ArraySerializer(FileMetadataSerializer()).serialize(value.entries),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> ListRevisionsResult {
            switch json {
                case .Dictionary(let dict):
                    let isDeleted = Serialization._BoolSerializer.deserialize(dict["is_deleted"] ?? .Null)
                    let entries = ArraySerializer(FileMetadataSerializer()).deserialize(dict["entries"] ?? .Null)
                    return ListRevisionsResult(isDeleted: isDeleted, entries: entries)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Arguments for `restore`.
    ///
    /// :param: path
    ///        The path to the file you want to restore.
    /// :param: rev
    ///        The revision to restore for the file.
    public class RestoreArg: CustomStringConvertible {
        public let path : String
        public let rev : String
        public init(path: String, rev: String) {
            stringValidator(pattern: "/.*")(value: path)
            self.path = path
            stringValidator(minLength: 9, pattern: "[0-9a-f]+")(value: rev)
            self.rev = rev
        }
        public var description : String {
            return "\(prepareJSONForSerialization(RestoreArgSerializer().serialize(self)))"
        }
    }
    public class RestoreArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RestoreArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "rev": Serialization._StringSerializer.serialize(value.rev),
            ]
            return .Dictionary(output)
        }
        public func deserialize(json: JSON) -> RestoreArg {
            switch json {
                case .Dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .Null)
                    let rev = Serialization._StringSerializer.deserialize(dict["rev"] ?? .Null)
                    return RestoreArg(path: path, rev: rev)
                default:
                    assert(false, "Type error deserializing")
            }
        }
    }
    /// Errors reported by `restore`.
    ///
    /// - PathLookup:
    ///   An error occurs when downloading metadata for the file.
    /// - PathWrite:
    ///   An error occurs when trying to restore the file to that path.
    /// - InvalidRevision:
    ///   The revision is invalid. It may point to a different file.
    public enum RestoreError : CustomStringConvertible {
        case PathLookup(Files.LookupError)
        case PathWrite(Files.WriteError)
        case InvalidRevision
        public var description : String {
            return "\(prepareJSONForSerialization(RestoreErrorSerializer().serialize(self)))"
        }
    }
    public class RestoreErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(value: RestoreError) -> JSON {
            switch value {
                case .PathLookup(let arg):
                    var d = ["path_lookup": LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("path_lookup")
                    return .Dictionary(d)
                case .PathWrite(let arg):
                    var d = ["path_write": WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .Str("path_write")
                    return .Dictionary(d)
                case .InvalidRevision:
                    var d = [String : JSON]()
                    d[".tag"] = .Str("invalid_revision")
                    return .Dictionary(d)
            }
        }
        public func deserialize(json: JSON) -> RestoreError {
            switch json {
                case .Dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path_lookup":
                            let v = LookupErrorSerializer().deserialize(d["path_lookup"] ?? .Null)
                            return RestoreError.PathLookup(v)
                        case "path_write":
                            let v = WriteErrorSerializer().deserialize(d["path_write"] ?? .Null)
                            return RestoreError.PathWrite(v)
                        case "invalid_revision":
                            return RestoreError.InvalidRevision
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    assert(false, "Failed to deserialize")
            }
        }
    }
}
extension BabelClient {
    /// Returns the metadata for a file or folder.
    ///
    /// :param: path
    ///        The path of a file or folder on Dropbox
    public func filesGetMetadata(path path: String) -> BabelRpcRequest<Files.MetadataSerializer, Files.GetMetadataErrorSerializer> {
        let request = Files.GetMetadataArg(path: path)
        return BabelRpcRequest(client: self, host: "meta", route: "/files/get_metadata", params: Files.GetMetadataArgSerializer().serialize(request), responseSerializer: Files.MetadataSerializer(), errorSerializer: Files.GetMetadataErrorSerializer())
    }
    /// A longpoll endpoint to wait for changes on an account. In conjunction
    /// with :route:`list_folder`, this call gives you a low-latency way to
    /// monitor an account for file changes. The connection will block until
    /// there are changes available or a timeout occurs.
    ///
    /// :param: cursor
    ///        A cursor as returned by `list_folder` or `list_folder/continue`
    /// :param: timeout
    ///        A timeout in seconds. The request will block for at most this
    ///        length of time, plus up to 90 seconds of random jitter added to
    ///        avoid the thundering herd problem. Care should be taken when
    ///        using this parameter, as some network infrastructure does not
    ///        support long timeouts.
    public func filesListFolderLongpoll(cursor cursor: String, timeout: UInt64 = 30) -> BabelRpcRequest<Files.ListFolderLongpollResultSerializer, Files.ListFolderLongpollErrorSerializer> {
        let request = Files.ListFolderLongpollArg(cursor: cursor, timeout: timeout)
        return BabelRpcRequest(client: self, host: "notify", route: "/files/list_folder/longpoll", params: Files.ListFolderLongpollArgSerializer().serialize(request), responseSerializer: Files.ListFolderLongpollResultSerializer(), errorSerializer: Files.ListFolderLongpollErrorSerializer())
    }
    /// Returns the contents of a folder. NOTE: We're definitely going to
    /// streamline this interface.
    ///
    /// :param: path
    ///        The path to the folder you want to see the contents of.
    /// :param: recursive
    ///        If true, list folder operation will be applied recursively to all
    ///        subfolders. And the response will contain contents of all
    ///        subfolders
    public func filesListFolder(path path: String, recursive: Bool = false) -> BabelRpcRequest<Files.ListFolderResultSerializer, Files.ListFolderErrorSerializer> {
        let request = Files.ListFolderArg(path: path, recursive: recursive)
        return BabelRpcRequest(client: self, host: "meta", route: "/files/list_folder", params: Files.ListFolderArgSerializer().serialize(request), responseSerializer: Files.ListFolderResultSerializer(), errorSerializer: Files.ListFolderErrorSerializer())
    }
    /// Once a cursor has been retrieved from :route:`list_folder`, use this to
    /// paginate through all files and retrieve updates to the folder. NOTE:
    /// We're definitely going to streamline this interface.
    ///
    /// :param: cursor
    ///        The cursor returned by `list_folder` or `list_folder/continue`.
    public func filesListFolderContinue(cursor cursor: String) -> BabelRpcRequest<Files.ListFolderResultSerializer, Files.ListFolderContinueErrorSerializer> {
        let request = Files.ListFolderContinueArg(cursor: cursor)
        return BabelRpcRequest(client: self, host: "meta", route: "/files/list_folder/continue", params: Files.ListFolderContinueArgSerializer().serialize(request), responseSerializer: Files.ListFolderResultSerializer(), errorSerializer: Files.ListFolderContinueErrorSerializer())
    }
    /// A way to quickly get a cursor for the folder's state. Unlike
    /// :route:`list_folder`, :route:`list_folder/get_latest_cursor` doesn't
    /// return any entries. This endpoint is for app which only needs to know
    /// about new files and modifications and doesn't need to know about files
    /// that already exist in Dropbox.
    ///
    /// :param: path
    ///        The path to the folder you want to see the contents of.
    /// :param: recursive
    ///        If true, list folder operation will be applied recursively to all
    ///        subfolders. And the response will contain contents of all
    ///        subfolders
    public func filesListFolderGetLatestCursor(path path: String, recursive: Bool = false) -> BabelRpcRequest<Files.ListFolderGetLatestCursorResultSerializer, Files.ListFolderErrorSerializer> {
        let request = Files.ListFolderArg(path: path, recursive: recursive)
        return BabelRpcRequest(client: self, host: "meta", route: "/files/list_folder/get_latest_cursor", params: Files.ListFolderArgSerializer().serialize(request), responseSerializer: Files.ListFolderGetLatestCursorResultSerializer(), errorSerializer: Files.ListFolderErrorSerializer())
    }
    /// Download a file from a user's Dropbox.
    ///
    /// :param: path
    ///        The path of the file to download.
    /// :param: rev
    ///        Optional revision, taken from the corresponding `Metadata` field.
    public func filesDownload(path path: String, rev: String? = nil) -> BabelDownloadRequest<Files.FileMetadataSerializer, Files.DownloadErrorSerializer> {
        let request = Files.DownloadArg(path: path, rev: rev)
        return BabelDownloadRequest(client: self, host: "content", route: "/files/download", params: Files.DownloadArgSerializer().serialize(request), responseSerializer: Files.FileMetadataSerializer(), errorSerializer: Files.DownloadErrorSerializer())
    }
    /// Start a new upload session. This is used to upload a single file with
    /// multiple calls.
    ///
    /// :param: body
    ///        The binary payload to upload
    public func filesUploadSessionStart(body body: NSData) -> BabelUploadRequest<Files.UploadSessionStartResultSerializer, VoidSerializer> {
        return BabelUploadRequest(client: self, host: "content", route: "/files/upload_session/start", params: Serialization._VoidSerializer.serialize(), body: body, responseSerializer: Files.UploadSessionStartResultSerializer(), errorSerializer: Serialization._VoidSerializer)
    }
    /// Append more data to an upload session.
    ///
    /// :param: sessionId
    ///        The upload session ID (returned by `upload_session/start`).
    /// :param: offset
    ///        The amount of data that has been uploaded so far. We use this to
    ///        make sure upload data isn't lost or duplicated in the event of a
    ///        network error.
    /// :param: body
    ///        The binary payload to upload
    public func filesUploadSessionAppend(sessionId sessionId: String, offset: UInt64, body: NSData) -> BabelUploadRequest<VoidSerializer, Files.UploadSessionLookupErrorSerializer> {
        let request = Files.UploadSessionCursor(sessionId: sessionId, offset: offset)
        return BabelUploadRequest(client: self, host: "content", route: "/files/upload_session/append", params: Files.UploadSessionCursorSerializer().serialize(request), body: body, responseSerializer: Serialization._VoidSerializer, errorSerializer: Files.UploadSessionLookupErrorSerializer())
    }
    /// Finish an upload session and save the uploaded data to the given file
    /// path.
    ///
    /// :param: cursor
    ///        Contains the upload session ID and the offset.
    /// :param: commit
    ///        Contains the path and other optional modifiers for the commit.
    /// :param: body
    ///        The binary payload to upload
    public func filesUploadSessionFinish(cursor cursor: Files.UploadSessionCursor, commit: Files.CommitInfo, body: NSData) -> BabelUploadRequest<Files.FileMetadataSerializer, Files.UploadSessionFinishErrorSerializer> {
        let request = Files.UploadSessionFinishArg(cursor: cursor, commit: commit)
        return BabelUploadRequest(client: self, host: "content", route: "/files/upload_session/finish", params: Files.UploadSessionFinishArgSerializer().serialize(request), body: body, responseSerializer: Files.FileMetadataSerializer(), errorSerializer: Files.UploadSessionFinishErrorSerializer())
    }
    /// Create a new file with the contents provided in the request.
    ///
    /// :param: path
    ///        Path in the user's Dropbox to save the file.
    /// :param: mode
    ///        Selects what to do if the file already exists.
    /// :param: autorename
    ///        If there's a conflict, as determined by `mode`, have the Dropbox
    ///        server try to autorename the file to avoid conflict.
    /// :param: clientModified
    ///        The value to store as the `client_modified` timestamp. Dropbox
    ///        automatically records the time at which the file was written to
    ///        the Dropbox servers. It can also record an additional timestamp,
    ///        provided by Dropbox desktop clients, mobile clients, and API apps
    ///        of when the file was actually created or modified.
    /// :param: mute
    ///        Normally, users are made aware of any file modifications in their
    ///        Dropbox account via notifications in the client software. If
    ///        `true`, this tells the clients that this modification shouldn't
    ///        result in a user notification.
    /// :param: body
    ///        The binary payload to upload
    public func filesUpload(path path: String, mode: Files.WriteMode = .Add, autorename: Bool = false, clientModified: NSDate? = nil, mute: Bool = false, body: NSData) -> BabelUploadRequest<Files.FileMetadataSerializer, Files.UploadErrorSerializer> {
        let request = Files.CommitInfo(path: path, mode: mode, autorename: autorename, clientModified: clientModified, mute: mute)
        return BabelUploadRequest(client: self, host: "content", route: "/files/upload", params: Files.CommitInfoSerializer().serialize(request), body: body, responseSerializer: Files.FileMetadataSerializer(), errorSerializer: Files.UploadErrorSerializer())
    }
    /// Searches for files and folders.
    ///
    /// :param: path
    ///        The path in the user's Dropbox to search. Should probably be a
    ///        folder.
    /// :param: query
    ///        The string to search for. The search string is split on spaces
    ///        into multiple tokens. For file name searching, the last token is
    ///        used for prefix matching (i.e. "bat c" matches "bat cave" but not
    ///        "batman car").
    /// :param: start
    ///        The starting index within the search results (used for paging).
    /// :param: maxResults
    ///        The maximum number of search results to return.
    /// :param: mode
    ///        The search mode (filename, filename_and_content, or
    ///        deleted_filename).
    public func filesSearch(path path: String, query: String, start: UInt64 = 0, maxResults: UInt64 = 100, mode: Files.SearchMode = .Filename) -> BabelRpcRequest<Files.SearchResultsSerializer, Files.SearchErrorSerializer> {
        let request = Files.SearchQuery(path: path, query: query, start: start, maxResults: maxResults, mode: mode)
        return BabelRpcRequest(client: self, host: "meta", route: "/files/search", params: Files.SearchQuerySerializer().serialize(request), responseSerializer: Files.SearchResultsSerializer(), errorSerializer: Files.SearchErrorSerializer())
    }
    /// Create a folder at a given path. No file or folder may exist at the
    /// path. The parent folder will be created if it does not already exist
    /// (and so on). If the parent exists it must be a folder (and the same for
    /// any ancestor). If an ancestor is a shared folder it must have write
    /// access.
    ///
    /// :param: path
    ///        Path in the user's Dropbox to create.
    public func filesCreateFolder(path path: String) -> BabelRpcRequest<Files.FolderMetadataSerializer, Files.CreateFolderErrorSerializer> {
        let request = Files.CreateFolderArg(path: path)
        return BabelRpcRequest(client: self, host: "meta", route: "/files/create_folder", params: Files.CreateFolderArgSerializer().serialize(request), responseSerializer: Files.FolderMetadataSerializer(), errorSerializer: Files.CreateFolderErrorSerializer())
    }
    /// Delete the file or folder at a given path. If the path is a folder all
    /// its contents will be deleted too.
    ///
    /// :param: path
    ///        Path in the user's Dropbox to delete.
    public func filesDelete(path path: String) -> BabelRpcRequest<Files.MetadataSerializer, Files.DeleteErrorSerializer> {
        let request = Files.DeleteArg(path: path)
        return BabelRpcRequest(client: self, host: "meta", route: "/files/delete", params: Files.DeleteArgSerializer().serialize(request), responseSerializer: Files.MetadataSerializer(), errorSerializer: Files.DeleteErrorSerializer())
    }
    /// Copy a file or folder to a different destination in the user's Dropbox.
    /// If the source path is a folder all its contents will be copied. The
    /// destination path must not yet exist.
    ///
    /// :param: fromPath
    ///        Path in the user's Dropbox to be copied or moved.
    /// :param: toPath
    ///        Path in the user's Dropbox that is the destination.
    public func filesCopy(fromPath fromPath: String, toPath: String) -> BabelRpcRequest<Files.MetadataSerializer, Files.RelocationErrorSerializer> {
        let request = Files.RelocationArg(fromPath: fromPath, toPath: toPath)
        return BabelRpcRequest(client: self, host: "meta", route: "/files/copy", params: Files.RelocationArgSerializer().serialize(request), responseSerializer: Files.MetadataSerializer(), errorSerializer: Files.RelocationErrorSerializer())
    }
    /// Move a file or folder to a different destination in the user's Dropbox.
    /// If the source path is a folder all its contents will be moved. The
    /// destination path must not yet exist.
    ///
    /// :param: fromPath
    ///        Path in the user's Dropbox to be copied or moved.
    /// :param: toPath
    ///        Path in the user's Dropbox that is the destination.
    public func filesMove(fromPath fromPath: String, toPath: String) -> BabelRpcRequest<Files.MetadataSerializer, Files.RelocationErrorSerializer> {
        let request = Files.RelocationArg(fromPath: fromPath, toPath: toPath)
        return BabelRpcRequest(client: self, host: "meta", route: "/files/move", params: Files.RelocationArgSerializer().serialize(request), responseSerializer: Files.MetadataSerializer(), errorSerializer: Files.RelocationErrorSerializer())
    }
    /// Get a thumbnail for an image. This method currently supports files with
    /// the following file extensions: jpg, jpeg, png, tiff, tif, gif and bmp.
    /// Photos that are larger than 20MB in size won't be converted to a
    /// thumbnail.
    ///
    /// :param: path
    ///        The path to the image file you want to thumbnail.
    /// :param: format
    ///        The format for the thumbnail image, jpeg (default) or png. For
    ///        images that are photos, jpeg should be preferred, while png is
    ///        better for screenshots and digital arts.
    /// :param: size
    ///        The size for the thumbnail image.
    public func filesGetThumbnail(path path: String, format: Files.ThumbnailFormat = .Jpeg, size: Files.ThumbnailSize = .W64h64) -> BabelDownloadRequest<Files.FileMetadataSerializer, Files.ThumbnailErrorSerializer> {
        let request = Files.ThumbnailArg(path: path, format: format, size: size)
        return BabelDownloadRequest(client: self, host: "content", route: "/files/get_thumbnail", params: Files.ThumbnailArgSerializer().serialize(request), responseSerializer: Files.FileMetadataSerializer(), errorSerializer: Files.ThumbnailErrorSerializer())
    }
    /// Get a preview for a file. Currently previews are only generated for the
    /// files with  the following extensions: .doc, .docx, .docm, .ppt, .pps,
    /// .ppsx, .ppsm, .pptx, .pptm,  .xls, .xlsx, .xlsm, .rtf
    ///
    /// :param: path
    ///        The path of the file to preview.
    /// :param: rev
    ///        Optional revision, taken from the corresponding `Metadata` field.
    public func filesGetPreview(path path: String, rev: String? = nil) -> BabelDownloadRequest<Files.FileMetadataSerializer, Files.PreviewErrorSerializer> {
        let request = Files.PreviewArg(path: path, rev: rev)
        return BabelDownloadRequest(client: self, host: "content", route: "/files/get_preview", params: Files.PreviewArgSerializer().serialize(request), responseSerializer: Files.FileMetadataSerializer(), errorSerializer: Files.PreviewErrorSerializer())
    }
    /// Return revisions of a file
    ///
    /// :param: path
    ///        The path to the file you want to see the revisions of.
    /// :param: limit
    ///        The maximum number of revision entries returned.
    public func filesListRevisions(path path: String, limit: UInt64 = 10) -> BabelRpcRequest<Files.ListRevisionsResultSerializer, Files.ListRevisionsErrorSerializer> {
        let request = Files.ListRevisionsArg(path: path, limit: limit)
        return BabelRpcRequest(client: self, host: "meta", route: "/files/list_revisions", params: Files.ListRevisionsArgSerializer().serialize(request), responseSerializer: Files.ListRevisionsResultSerializer(), errorSerializer: Files.ListRevisionsErrorSerializer())
    }
    /// Restore a file to a specific revision
    ///
    /// :param: path
    ///        The path to the file you want to restore.
    /// :param: rev
    ///        The revision to restore for the file.
    public func filesRestore(path path: String, rev: String) -> BabelRpcRequest<Files.FileMetadataSerializer, Files.RestoreErrorSerializer> {
        let request = Files.RestoreArg(path: path, rev: rev)
        return BabelRpcRequest(client: self, host: "meta", route: "/files/restore", params: Files.RestoreArgSerializer().serialize(request), responseSerializer: Files.FileMetadataSerializer(), errorSerializer: Files.RestoreErrorSerializer())
    }
}
